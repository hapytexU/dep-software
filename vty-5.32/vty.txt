-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple terminal UI library
--   
--   vty is terminal GUI library in the niche of ncurses. It is intended to
--   be easy to use, have no confusing corner cases, and good support for
--   common terminal types.
--   
--   See the <tt>vty-examples</tt> package as well as the program
--   <tt>test/interactive_terminal_test.hs</tt> included in the
--   <tt>vty</tt> package for examples on how to use the library.
--   
--   Import the <a>Graphics.Vty</a> convenience module to get access to the
--   core parts of the library.
--   
--   © 2006-2007 Stefan O'Rear; BSD3 license.
--   
--   © Corey O'Connor; BSD3 license.
--   
--   © Jonathan Daugherty; BSD3 license.
@package vty
@version 5.32


-- | This module provides functions to measure the terminal column width of
--   characters and strings.
--   
--   The functions provided in this module all ultimately make calls to the
--   C implementation in <tt>cbits/mk_wcwidth.c</tt>. That code manages
--   some global state that carries a table of Unicode character widths.
--   For more details, see <a>Install</a>, the C code, and the
--   "Multi-Column Character Support" section of the project
--   <tt>README</tt>.
module Graphics.Text.Width
wcwidth :: Char -> Int
wcswidth :: String -> Int
wctwidth :: Text -> Int
wctlwidth :: Text -> Int

-- | Returns the display width of a character. Assumes all characters with
--   unknown widths are 0 width.
safeWcwidth :: Char -> Int

-- | Returns the display width of a string. Assumes all characters with
--   unknown widths are 0 width.
safeWcswidth :: String -> Int

-- | Returns the display width of a text. Assumes all characters with
--   unknown widths are 0 width.
safeWctwidth :: Text -> Int

-- | Returns the display width of a lazy text. Assumes all characters with
--   unknown widths are 0 width.
safeWctlwidth :: Text -> Int

module Graphics.Vty.Attributes.Color

-- | Abstract data type representing a color.
--   
--   Currently the foreground and background color are specified as points
--   in either a:
--   
--   <ul>
--   <li>16 color palette. Where the first 8 colors are equal to the 8
--   colors of the ISO 6429 (ANSI) 8 color palette and the second 8 colors
--   are bright/vivid versions of the first 8 colors.</li>
--   <li>240 color palette. This palette is a regular sampling of the full
--   RGB colorspace for the first 224 colors. The remaining 16 colors is a
--   greyscale palette.</li>
--   </ul>
--   
--   The 8 ISO 6429 (ANSI) colors are as follows:
--   
--   <ol>
--   <li>black</li>
--   <li>red</li>
--   <li>green</li>
--   <li>yellow</li>
--   <li>blue</li>
--   <li>magenta</li>
--   <li>cyan</li>
--   <li>white</li>
--   </ol>
--   
--   The mapping from points in the 240 color palette to colors actually
--   displayable by the terminal depends on the number of colors the
--   terminal claims to support. Which is usually determined by the
--   terminfo "colors" property. If this property is not being accurately
--   reported then the color reproduction will be incorrect.
--   
--   If the terminal reports &lt;= 16 colors then the 240 color palette
--   points are only mapped to the 8 color pallete. I'm not sure of the RGB
--   points for the "bright" colors which is why they are not addressable
--   via the 240 color palette.
--   
--   If the terminal reports &gt; 16 colors then the 240 color palette
--   points are mapped to the nearest points in a ("color count" - 16)
--   subsampling of the 240 color palette.
--   
--   All of this assumes the terminals are behaving similarly to xterm and
--   rxvt when handling colors. And that the individual colors have not
--   been remapped by the user. There may be a way to verify this through
--   terminfo but I don't know it.
--   
--   Seriously, terminal color support is INSANE.
data Color
ISOColor :: !Word8 -> Color
Color240 :: !Word8 -> Color
black :: Color
red :: Color
green :: Color
yellow :: Color
blue :: Color
magenta :: Color
cyan :: Color
white :: Color
brightBlack :: Color
brightRed :: Color
brightGreen :: Color
brightYellow :: Color
brightBlue :: Color
brightMagenta :: Color
brightCyan :: Color
brightWhite :: Color

-- | Create a Vty <a>Color</a> (in the 240 color set) from an RGB triple.
--   This function is lossy in the sense that we only internally support
--   240 colors but the #RRGGBB format supports 16^3 colors.
rgbColor :: Integral i => i -> i -> i -> Color

-- | Create a value in the Color240 set from an RGB triple
rgbColorToColor240 :: Integral i => i -> i -> i -> Word8

-- | Create a RGB triple from a value in the Color240 set.
color240CodeToRGB :: Word8 -> Maybe (Int, Int, Int)
instance Control.DeepSeq.NFData Graphics.Vty.Attributes.Color.Color
instance GHC.Generics.Generic Graphics.Vty.Attributes.Color.Color
instance GHC.Read.Read Graphics.Vty.Attributes.Color.Color
instance GHC.Show.Show Graphics.Vty.Attributes.Color.Color
instance GHC.Classes.Eq Graphics.Vty.Attributes.Color.Color


-- | Display attributes
--   
--   Attributes have three components: a foreground color, a background
--   color, and a style mask. The simplest attribute is the default
--   attribute, or <a>defAttr</a>. Attributes can be modified with
--   <a>withForeColor</a>, <a>withBackColor</a>, and <a>withStyle</a>,
--   e.g.,
--   
--   <pre>
--   defAttr `withForeColor` red
--   </pre>
--   
--   <tt>Image</tt> constructors often require an <a>Attr</a> to indicate
--   the attributes used in the image, e.g.,
--   
--   <pre>
--   string (defAttr `withForeColor` red) "this text will be red"
--   </pre>
--   
--   The appearance of <tt>Image</tt>s using <a>defAttr</a> is determined
--   by the The terminal, so this is not something VTY can control. The
--   user is free to The define the color scheme of the terminal as they
--   see fit.
--   
--   The value <a>currentAttr</a> will keep the attributes of whatever was
--   output previously.
module Graphics.Vty.Attributes

-- | A display attribute defines the Color and Style of all the characters
--   rendered after the attribute is applied.
--   
--   At most 256 colors, picked from a 240 and 16 color palette, are
--   possible for the background and foreground. The 240 colors and 16
--   colors are points in different palettes. See Color for more
--   information.
data Attr
Attr :: !MaybeDefault Style -> !MaybeDefault Color -> !MaybeDefault Color -> !MaybeDefault Text -> Attr
[attrStyle] :: Attr -> !MaybeDefault Style
[attrForeColor] :: Attr -> !MaybeDefault Color
[attrBackColor] :: Attr -> !MaybeDefault Color
[attrURL] :: Attr -> !MaybeDefault Text

-- | Specifies the display attributes such that the final style and color
--   values do not depend on the previously applied display attribute. The
--   display attributes can still depend on the terminal's default colors
--   (unfortunately).
data FixedAttr
FixedAttr :: !Style -> !Maybe Color -> !Maybe Color -> !Maybe Text -> FixedAttr
[fixedStyle] :: FixedAttr -> !Style
[fixedForeColor] :: FixedAttr -> !Maybe Color
[fixedBackColor] :: FixedAttr -> !Maybe Color
[fixedURL] :: FixedAttr -> !Maybe Text

-- | The style and color attributes can either be the terminal defaults. Or
--   be equivalent to the previously applied style. Or be a specific value.
data MaybeDefault v
[Default] :: MaybeDefault v
[KeepCurrent] :: MaybeDefault v
[SetTo] :: forall v. (Eq v, Show v, Read v) => !v -> MaybeDefault v

-- | Sets the style, background color and foreground color to the default
--   values for the terminal. There is no easy way to determine what the
--   default background and foreground colors are.
defAttr :: Attr

-- | Keeps the style, background color and foreground color that was
--   previously set. Used to override some part of the previous style.
--   
--   EG: current_style <a>withForeColor</a> brightMagenta
--   
--   Would be the currently applied style (be it underline, bold, etc) but
--   with the foreground color set to brightMagenta.
currentAttr :: Attr

-- | Styles are represented as an 8 bit word. Each bit in the word is 1 if
--   the style attribute assigned to that bit should be applied and 0 if
--   the style attribute should not be applied.
type Style = Word8

-- | Add the given style attribute
withStyle :: Attr -> Style -> Attr

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
standout :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
italic :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
strikethrough :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
underline :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
reverseVideo :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
blink :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
dim :: Style

-- | Valid style attributes include:
--   
--   <ul>
--   <li>standout</li>
--   <li>underline</li>
--   <li>reverseVideo</li>
--   <li>blink</li>
--   <li>dim</li>
--   <li>bold/bright</li>
--   <li>italic</li>
--   <li>strikethrough (via the smxx/rmxx terminfo capabilities)</li>
--   </ul>
--   
--   (The invisible, protect, and altcharset display attributes some
--   terminals support are not supported via VTY.)
bold :: Style
defaultStyleMask :: Style
styleMask :: Attr -> Word8

-- | true if the given Style value has the specified Style set.
hasStyle :: Style -> Style -> Bool

-- | Set the foreground color of an <a>Attr</a>.
withForeColor :: Attr -> Color -> Attr

-- | Set the background color of an <a>Attr</a>.
withBackColor :: Attr -> Color -> Attr

-- | Add a hyperlinked URL using the proposed <a>escape sequences for
--   hyperlinked URLs</a>. These escape sequences are comparatively new and
--   aren't widely supported in terminal emulators yet, but most terminal
--   emulators that don't know about these sequences will ignore these
--   sequences, and therefore this should fall back sensibly. In some cases
--   they won't and this will result in garbage, so this is why
--   hyperlinking is disabled by default, in which case this combinator has
--   no observable effect. To enable it, enable <tt>Hyperlink</tt> mode on
--   your Vty output interface.
withURL :: Attr -> Text -> Attr
instance GHC.Show.Show Graphics.Vty.Attributes.FixedAttr
instance GHC.Classes.Eq Graphics.Vty.Attributes.FixedAttr
instance Control.DeepSeq.NFData Graphics.Vty.Attributes.Attr
instance GHC.Generics.Generic Graphics.Vty.Attributes.Attr
instance GHC.Read.Read Graphics.Vty.Attributes.Attr
instance GHC.Show.Show Graphics.Vty.Attributes.Attr
instance GHC.Classes.Eq Graphics.Vty.Attributes.Attr
instance GHC.Classes.Eq v => GHC.Classes.Eq (Graphics.Vty.Attributes.MaybeDefault v)
instance GHC.Classes.Eq v => GHC.Show.Show (Graphics.Vty.Attributes.MaybeDefault v)
instance (GHC.Classes.Eq v, GHC.Show.Show v, GHC.Read.Read v) => GHC.Read.Read (Graphics.Vty.Attributes.MaybeDefault v)
instance GHC.Base.Semigroup Graphics.Vty.Attributes.Attr
instance GHC.Base.Monoid Graphics.Vty.Attributes.Attr
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Graphics.Vty.Attributes.MaybeDefault v)
instance GHC.Classes.Eq v => GHC.Base.Semigroup (Graphics.Vty.Attributes.MaybeDefault v)
instance GHC.Classes.Eq v => GHC.Base.Monoid (Graphics.Vty.Attributes.MaybeDefault v)

module Graphics.Vty.DisplayAttributes

-- | Given the previously applied display attributes as a FixedAttr and the
--   current display attributes as an Attr produces a FixedAttr that
--   represents the current display attributes. This is done by using the
--   previously applied display attributes to remove the <a>KeepCurrent</a>
--   abstraction.
fixDisplayAttr :: FixedAttr -> Attr -> FixedAttr

-- | difference between two display attributes. Used in the calculation of
--   the operations required to go from one display attribute to the next.
--   
--   Previously, vty would reset display attributes to default then apply
--   the new display attributes. This turned out to be very expensive: A
--   *lot* more data would be sent to the terminal than required.
data DisplayAttrDiff
DisplayAttrDiff :: [StyleStateChange] -> DisplayColorDiff -> DisplayColorDiff -> URLDiff -> DisplayAttrDiff
[styleDiffs] :: DisplayAttrDiff -> [StyleStateChange]
[foreColorDiff] :: DisplayAttrDiff -> DisplayColorDiff
[backColorDiff] :: DisplayAttrDiff -> DisplayColorDiff
[urlDiff] :: DisplayAttrDiff -> URLDiff

-- | Used in the computation of a final style attribute change.
simplifyStyleDiffs :: [StyleStateChange] -> [StyleStateChange] -> [StyleStateChange]

-- | Consider two display color attributes diffs. What display color
--   attribute diff are these equivalent to?
simplifyColorDiffs :: DisplayColorDiff -> DisplayColorDiff -> DisplayColorDiff

-- | Consider two URL changes, which are mostly going to be the latter
--   unless the latter specifies no change.
simplifyUrlDiffs :: URLDiff -> URLDiff -> URLDiff

-- | Difference between two display color attribute changes.
data DisplayColorDiff
ColorToDefault :: DisplayColorDiff
NoColorChange :: DisplayColorDiff
SetColor :: !Color -> DisplayColorDiff

-- | Style attribute changes are transformed into a sequence of
--   apply/removes of the individual attributes.
data StyleStateChange
ApplyStandout :: StyleStateChange
RemoveStandout :: StyleStateChange
ApplyItalic :: StyleStateChange
RemoveItalic :: StyleStateChange
ApplyStrikethrough :: StyleStateChange
RemoveStrikethrough :: StyleStateChange
ApplyUnderline :: StyleStateChange
RemoveUnderline :: StyleStateChange
ApplyReverseVideo :: StyleStateChange
RemoveReverseVideo :: StyleStateChange
ApplyBlink :: StyleStateChange
RemoveBlink :: StyleStateChange
ApplyDim :: StyleStateChange
RemoveDim :: StyleStateChange
ApplyBold :: StyleStateChange
RemoveBold :: StyleStateChange
data URLDiff
LinkTo :: !ByteString -> URLDiff
NoLinkChange :: URLDiff
EndLink :: URLDiff

-- | Determines the diff between two display&amp;color attributes. This
--   diff determines the operations that actually get output to the
--   terminal.
displayAttrDiffs :: FixedAttr -> FixedAttr -> DisplayAttrDiff
diffURL :: Maybe Text -> Maybe Text -> URLDiff
diffColor :: Maybe Color -> Maybe Color -> DisplayColorDiff
diffStyles :: Style -> Style -> [StyleStateChange]
instance GHC.Classes.Eq Graphics.Vty.DisplayAttributes.DisplayColorDiff
instance GHC.Show.Show Graphics.Vty.DisplayAttributes.DisplayColorDiff
instance GHC.Classes.Eq Graphics.Vty.DisplayAttributes.StyleStateChange
instance GHC.Show.Show Graphics.Vty.DisplayAttributes.StyleStateChange
instance GHC.Classes.Eq Graphics.Vty.DisplayAttributes.URLDiff
instance GHC.Show.Show Graphics.Vty.DisplayAttributes.URLDiff
instance GHC.Show.Show Graphics.Vty.DisplayAttributes.DisplayAttrDiff
instance GHC.Base.Semigroup Graphics.Vty.DisplayAttributes.DisplayAttrDiff
instance GHC.Base.Monoid Graphics.Vty.DisplayAttributes.DisplayAttrDiff

module Graphics.Vty.Error

-- | The type of exceptions specific to vty.
--   
--   These have fully qualified names by default since, IMO, exception
--   handling requires this.
data VtyException

-- | Uncategorized failure specific to vty.
VtyFailure :: String -> VtyException


-- | A Vty program makes <tt>Picture</tt>s from <a>Image</a>s. This module
--   provides the core constructors for creating, combining, and modifying
--   <a>Image</a>s.
module Graphics.Vty.Image

-- | This is the internal representation of Images. Use the constructors in
--   <a>Graphics.Vty.Image</a> to create instances.
--   
--   Images are:
--   
--   <ul>
--   <li>a horizontal span of text</li>
--   <li>a horizontal or vertical join of two images</li>
--   <li>a two dimensional fill of the <tt>Picture</tt>s background
--   character</li>
--   <li>a cropped image</li>
--   <li>an empty image of no size or content.</li>
--   </ul>
data Image

-- | The width of an Image. This is the number display columns the image
--   will occupy.
imageWidth :: Image -> Int

-- | The height of an Image. This is the number of display rows the image
--   will occupy.
imageHeight :: Image -> Int

-- | The empty image. Useful for fold combinators. These occupy no space
--   and do not affect display attributes.
emptyImage :: Image

-- | Make an image from a single character. This is a standard Haskell
--   31-bit character assumed to be in the ISO-10646 encoding.
char :: Attr -> Char -> Image

-- | Make an <a>Image</a> from a <a>String</a>.
--   
--   This is an alias for iso10646String since the usual case is that a
--   literal string like "foo" is represented internally as a list of ISO
--   10646 31 bit characters.
--   
--   Note: Keep in mind that GHC will compile source encoded as UTF-8 but
--   the literal strings, while UTF-8 encoded in the source, will be
--   transcoded to a ISO 10646 31 bit characters runtime representation.
string :: Attr -> String -> Image

-- | Make an image from a string of characters layed out on a single row
--   with the same display attribute. The string is assumed to be a
--   sequence of ISO-10646 characters. The input string should be sanitized
--   of escape sequences (ASCII 27) and carriage returns; otherwise layout
--   and attribute problems may result.
--   
--   Note: depending on how the Haskell compiler represents string
--   literals, a string literal in a UTF-8 encoded source file, for
--   example, may be represented as a ISO-10646 string. That is, I think,
--   the case with GHC 6.10. This means, for the most part, you don't need
--   to worry about the encoding format when outputting string literals.
--   Just provide the string literal directly to iso10646String or string.
iso10646String :: Attr -> String -> Image

-- | Make an <a>Image</a> from a string of characters layed out on a single
--   row. The input is assumed to be the bytes for UTF-8 encoded text.
utf8String :: Attr -> [Word8] -> Image

-- | Make an <a>Image</a> from a lazy text value. The text value should be
--   sanitized of escape sequences (ASCII 27) and carriage returns;
--   otherwise layout and attribute problems may result.
text :: Attr -> Text -> Image

-- | Make an <a>Image</a> from a text value. The text value should be
--   sanitized of escape sequences (ASCII 27) and carriage returns;
--   otherwise layout and attribute problems may result.
text' :: Attr -> Text -> Image

-- | An area of the picture's background (See <tt>Background</tt>).
backgroundFill :: Int -> Int -> Image

-- | Make an <a>Image</a> from a UTF-8 encoded lazy bytestring.
utf8Bytestring :: Attr -> ByteString -> Image

-- | Make an <a>Image</a> from a UTF-8 encoded strict bytestring.
utf8Bytestring' :: Attr -> ByteString -> Image

-- | Make an image filling a region with the specified character.
--   
--   If either the width or height are less than or equal to 0, then the
--   result is the empty image.
charFill :: Integral d => Attr -> Char -> d -> d -> Image

-- | combines two images side by side
--   
--   Combines text chunks where possible. Assures outputWidth and
--   outputHeight properties are not violated.
--   
--   The result image will have a width equal to the sum of the two images
--   width. And the height will equal the largest height of the two images.
--   The area not defined in one image due to a height missmatch will be
--   filled with the background pattern.
horizJoin :: Image -> Image -> Image

-- | Combines two images horizontally. This is an alias for
--   <a>horizJoin</a>.
--   
--   infixr 5
(<|>) :: Image -> Image -> Image
infixr 5 <|>

-- | combines two images vertically
--   
--   The result image will have a height equal to the sum of the heights of
--   both images. The width will equal the largest width of the two images.
--   The area not defined in one image due to a width missmatch will be
--   filled with the background pattern.
vertJoin :: Image -> Image -> Image

-- | Combines two images vertically. This is an alias for <a>vertJoin</a>.
--   
--   infixr 4
(<->) :: Image -> Image -> Image
infixr 4 <->

-- | Compose any number of images together horizontally, with the first in
--   the list being leftmost.
horizCat :: [Image] -> Image

-- | Compose any number of images vertically, with the first in the list
--   being topmost.
vertCat :: [Image] -> Image

-- | Ensure an image is no larger than the provided size. If the image is
--   larger then crop the right or bottom.
--   
--   This is equivalent to a vertical crop from the bottom followed by
--   horizontal crop from the right.
crop :: Int -> Int -> Image -> Image

-- | Crop an image's width. If the image's width is less than or equal to
--   the specified width then this operation has no effect. Otherwise the
--   image is cropped from the right.
cropRight :: Int -> Image -> Image

-- | Crop an image's width. If the image's width is less than or equal to
--   the specified width then this operation has no effect. Otherwise the
--   image is cropped from the left.
cropLeft :: Int -> Image -> Image

-- | Crop an image's height. If the image's height is less than or equal to
--   the specified height then this operation has no effect. Otherwise the
--   image is cropped from the bottom.
cropBottom :: Int -> Image -> Image

-- | Crop an image's height. If the image's height is less than or equal to
--   the specified height then this operation has no effect. Otherwise the
--   image is cropped from the top.
cropTop :: Int -> Image -> Image

-- | Pad the given image. This adds background character fills to the left,
--   top, right, bottom.
pad :: Int -> Int -> Int -> Int -> Image -> Image

-- | Generic resize. Pads and crops are added to ensure that the resulting
--   image matches the specified dimensions. This is biased to pad/crop the
--   right and bottom.
resize :: Int -> Int -> Image -> Image

-- | Resize the width. Pads and crops as required to assure the given
--   display width. This is biased to pad/crop on the right.
resizeWidth :: Int -> Image -> Image

-- | Resize the height. Pads and crops as required to assure the given
--   display height. This is biased to pad/crop on the bottom.
resizeHeight :: Int -> Image -> Image

-- | Translates an image by padding or cropping the left and top.
--   
--   If translation offsets are negative then the image is cropped.
translate :: Int -> Int -> Image -> Image

-- | Translates an image by padding or cropping its left side.
translateX :: Int -> Image -> Image

-- | Translates an image by padding or cropping its top.
translateY :: Int -> Image -> Image

-- | Returns the display width of a character. Assumes all characters with
--   unknown widths are 0 width.
safeWcwidth :: Char -> Int

-- | Returns the display width of a string. Assumes all characters with
--   unknown widths are 0 width.
safeWcswidth :: String -> Int

-- | Returns the display width of a text. Assumes all characters with
--   unknown widths are 0 width.
safeWctwidth :: Text -> Int

-- | Returns the display width of a lazy text. Assumes all characters with
--   unknown widths are 0 width.
safeWctlwidth :: Text -> Int
wcwidth :: Char -> Int
wcswidth :: String -> Int
wctwidth :: Text -> Int
wctlwidth :: Text -> Int

-- | A display text is a Data.Text.Lazy
type DisplayText = Text

-- | A region of the display (first width, then height)
type DisplayRegion = (Int, Int)
regionWidth :: DisplayRegion -> Int
regionHeight :: DisplayRegion -> Int

module Graphics.Vty.Input.Events

-- | Representations of non-modifier keys.
--   
--   <ul>
--   <li>KFun is indexed from 0 to 63. Range of supported FKeys varies by
--   terminal and keyboard.</li>
--   <li>KUpLeft, KUpRight, KDownLeft, KDownRight, KCenter support varies
--   by terminal and keyboard.</li>
--   <li>Actually, support for most of these but KEsc, KChar, KBS, and
--   KEnter vary by terminal and keyboard.</li>
--   </ul>
data Key
KEsc :: Key
KChar :: Char -> Key
KBS :: Key
KEnter :: Key
KLeft :: Key
KRight :: Key
KUp :: Key
KDown :: Key
KUpLeft :: Key
KUpRight :: Key
KDownLeft :: Key
KDownRight :: Key
KCenter :: Key
KFun :: Int -> Key
KBackTab :: Key
KPrtScr :: Key
KPause :: Key
KIns :: Key
KHome :: Key
KPageUp :: Key
KDel :: Key
KEnd :: Key
KPageDown :: Key
KBegin :: Key
KMenu :: Key

-- | Modifier keys. Key codes are interpreted such that users are more
--   likely to have Meta than Alt; for instance on the PC Linux console,
--   <a>MMeta</a> will generally correspond to the physical Alt key.
data Modifier
MShift :: Modifier
MCtrl :: Modifier
MMeta :: Modifier
MAlt :: Modifier

-- | Mouse buttons.
data Button
BLeft :: Button
BMiddle :: Button
BRight :: Button
BScrollUp :: Button
BScrollDown :: Button

-- | Events.
data Event

-- | A keyboard key was pressed with the specified modifiers.
EvKey :: Key -> [Modifier] -> Event

-- | A mouse button was pressed at the specified column and row. Any
--   modifiers available in the event are also provided.
EvMouseDown :: Int -> Int -> Button -> [Modifier] -> Event

-- | A mouse button was released at the specified column and row. Some
--   terminals report only that a button was released without specifying
--   which one; in that case, Nothing is provided. Otherwise Just the
--   button released is included in the event.
EvMouseUp :: Int -> Int -> Maybe Button -> Event

-- | If read from <tt>eventChannel</tt> this is the size at the time of the
--   signal. If read from <tt>nextEvent</tt> this is the size at the time
--   the event was processed by Vty. Typically these are the same, but if
--   somebody is resizing the terminal quickly they can be different.
EvResize :: Int -> Int -> Event

-- | A paste event occurs when a bracketed paste input sequence is
--   received. For terminals that support bracketed paste mode, these
--   events will be triggered on a paste event. Terminals that do not
--   support bracketed pastes will send the paste contents as ordinary
--   input (which is probably bad, so beware!) Note that the data is
--   provided in raw form and you'll have to decode (e.g. as UTF-8) if
--   that's what your application expects.
EvPaste :: ByteString -> Event

-- | The terminal running the application lost input focus.
EvLostFocus :: Event

-- | The terminal running the application gained input focus.
EvGainedFocus :: Event
type ClassifyMap = [(String, Event)]
instance GHC.Generics.Generic Graphics.Vty.Input.Events.Key
instance GHC.Classes.Ord Graphics.Vty.Input.Events.Key
instance GHC.Read.Read Graphics.Vty.Input.Events.Key
instance GHC.Show.Show Graphics.Vty.Input.Events.Key
instance GHC.Classes.Eq Graphics.Vty.Input.Events.Key
instance GHC.Generics.Generic Graphics.Vty.Input.Events.Modifier
instance GHC.Classes.Ord Graphics.Vty.Input.Events.Modifier
instance GHC.Read.Read Graphics.Vty.Input.Events.Modifier
instance GHC.Show.Show Graphics.Vty.Input.Events.Modifier
instance GHC.Classes.Eq Graphics.Vty.Input.Events.Modifier
instance GHC.Generics.Generic Graphics.Vty.Input.Events.Button
instance GHC.Classes.Ord Graphics.Vty.Input.Events.Button
instance GHC.Read.Read Graphics.Vty.Input.Events.Button
instance GHC.Show.Show Graphics.Vty.Input.Events.Button
instance GHC.Classes.Eq Graphics.Vty.Input.Events.Button
instance GHC.Generics.Generic Graphics.Vty.Input.Events.Event
instance GHC.Classes.Ord Graphics.Vty.Input.Events.Event
instance GHC.Read.Read Graphics.Vty.Input.Events.Event
instance GHC.Show.Show Graphics.Vty.Input.Events.Event
instance GHC.Classes.Eq Graphics.Vty.Input.Events.Event


-- | This module exports the input classification type to avoid import
--   cycles between other modules that need this.
module Graphics.Vty.Input.Classify.Types
data KClass

-- | A valid event was parsed. Any unused characters from the input stream
--   are also provided.
Valid :: Event -> [Char] -> KClass

-- | The input characters did not represent a valid event.
Invalid :: KClass

-- | The input characters form the prefix of a valid event character
--   sequence.
Prefix :: KClass
instance GHC.Classes.Eq Graphics.Vty.Input.Classify.Types.KClass
instance GHC.Show.Show Graphics.Vty.Input.Classify.Types.KClass


-- | This module provides a simple parser for parsing input event control
--   sequences.
module Graphics.Vty.Input.Classify.Parse
type Parser a = MaybeT (State String) a

-- | Run a parser on a given input string. If the parser fails, return
--   <a>Invalid</a>. Otherwise return the valid event (<a>Valid</a>) and
--   the remaining unparsed characters.
runParser :: String -> Parser Event -> KClass

-- | Fail a parsing operation.
failParse :: Parser a

-- | Read an integer from the input stream. If an integer cannot be read,
--   fail parsing. E.g. calling readInt on an input of "123abc" will return
--   '123' and consume those characters.
readInt :: Parser Int

-- | Read a character from the input stream. If one cannot be read (e.g. we
--   are out of characters), fail parsing.
readChar :: Parser Char

-- | Read a character from the input stream and fail parsing if it is not
--   the specified character.
expectChar :: Char -> Parser ()


-- | Vty supports a configuration file format and associated <a>Config</a>
--   data type. The <a>Config</a> can be provided to <tt>mkVty</tt> to
--   customize the application's use of Vty.
--   
--   Lines in config files that fail to parse are ignored. Later entries
--   take precedence over earlier ones.
--   
--   <h1>Debug</h1>
--   
--   <h2><tt>debugLog</tt></h2>
--   
--   Format:
--   
--   <pre>
--   "debugLog" string
--   </pre>
--   
--   The value of the environment variable <tt>VTY_DEBUG_LOG</tt> is
--   equivalent to a debugLog entry at the end of the last config file.
--   
--   <h1>Input Processing</h1>
--   
--   <h2><tt>map</tt></h2>
--   
--   Format:
--   
--   <pre>
--   "map" term string key modifier_list
--   where
--       key := KEsc | KChar Char | KBS ... (same as <a>Key</a>)
--       modifier_list := "[" modifier+ "]"
--       modifier := MShift | MCtrl | MMeta | MAlt
--       term := "_" | string
--   </pre>
--   
--   E.g., if the contents are
--   
--   <pre>
--   map _       "\ESC[B"    KUp   []
--   map _       "\ESC[1;3B" KDown [MAlt]
--   map "xterm" "\ESC[D"    KLeft []
--   </pre>
--   
--   Then the bytes <tt>"\ESC[B"</tt> will result in the KUp event on all
--   terminals. The bytes <tt>"\ESC[1;3B"</tt> will result in the event
--   KDown with the MAlt modifier on all terminals. The bytes
--   <tt>"\ESC[D"</tt> will result in the KLeft event when <tt>TERM</tt> is
--   <tt>xterm</tt>.
--   
--   If a debug log is requested then vty will output the current input
--   table to the log in the above format. A workflow for using this is to
--   set <tt>VTY_DEBUG_LOG</tt>. Run the application. Check the debug log
--   for incorrect mappings. Add corrected mappings to
--   <tt>$HOME<i>.vty</i>config</tt>.
--   
--   <h1>Unicode Character Width Maps</h1>
--   
--   <h2><tt>widthMap</tt></h2>
--   
--   Format:
--   
--   <pre>
--   "widthMap" string string
--   </pre>
--   
--   E.g.,
--   
--   <pre>
--   widthMap "xterm" "/home/user/.vty/xterm_map.dat"
--   </pre>
--   
--   This directive specifies the path to a Unicode character width map
--   (the second argument) that should be loaded and used when the value of
--   TERM matches the first argument. Unicode character width maps can be
--   produced either by running the provided binary
--   <tt>vty-build-width-table</tt> or by calling the library routine
--   <a>buildUnicodeWidthTable</a>. The <a>mkVty</a> function will use
--   these configuration settings to attempt to load and install the
--   specified width map. See the documentation for <a>mkVty</a> for
--   details.
module Graphics.Vty.Config

-- | Mappings from input bytes to event in the order specified. Later
--   entries take precedence over earlier in the case multiple entries have
--   the same byte string.
type InputMap = [(Maybe String, String, Event)]

-- | A Vty configuration.
data Config
Config :: Maybe Int -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe FilePath -> InputMap -> Maybe Fd -> Maybe Fd -> Maybe String -> [(String, FilePath)] -> Maybe Bool -> Config

-- | The default is 1 character.
[vmin] :: Config -> Maybe Int

-- | The default is 100 milliseconds, 0.1 seconds.
[vtime] :: Config -> Maybe Int

-- | The default is False.
[mouseMode] :: Config -> Maybe Bool

-- | The default is False.
[bracketedPasteMode] :: Config -> Maybe Bool

-- | Debug information is appended to this file if not Nothing.
[debugLog] :: Config -> Maybe FilePath

-- | The (input byte, output event) pairs extend the internal input table
--   of VTY and the table from terminfo.
--   
--   See <a>Graphics.Vty.Config</a> module documentation for documentation
--   of the <tt>map</tt> directive.
[inputMap] :: Config -> InputMap

-- | The input file descriptor to use. The default is <a>stdInput</a>
[inputFd] :: Config -> Maybe Fd

-- | The output file descriptor to use. The default is <a>stdOutput</a>
[outputFd] :: Config -> Maybe Fd

-- | The terminal name used to look up terminfo capabilities. The default
--   is the value of the TERM environment variable.
[termName] :: Config -> Maybe String

-- | Terminal width map files.
[termWidthMaps] :: Config -> [(String, FilePath)]

-- | Whether to permit custom Unicode width table loading by <a>mkVty</a>.
--   <tt><a>Just</a> <a>False</a></tt> indicates that table loading should
--   not be performed. Other values permit table loading.
--   
--   If a table load is attempted and fails, information about the failure
--   will be logged to the debug log if the configuration specifies one. If
--   no custom table is loaded (or if a load fails), the built-in character
--   width table will be used.
[allowCustomUnicodeWidthTables] :: Config -> Maybe Bool

-- | Type of errors that can be thrown when configuring VTY
data VtyConfigurationError

-- | TERM environment variable not set
VtyMissingTermEnvVar :: VtyConfigurationError

-- | Load a configuration from <a>vtyConfigPath</a> and
--   <tt>$VTY_CONFIG_FILE</tt>.
userConfig :: IO Config
overrideEnvConfig :: IO Config

-- | Configures VTY using defaults suitable for terminals. This function
--   can raise <a>VtyConfigurationError</a>.
standardIOConfig :: IO Config
runParseConfig :: String -> ByteString -> Config
parseConfigFile :: FilePath -> IO Config
defaultConfig :: Config

-- | Get the "erase" character for the terminal attached to the specified
--   file descriptor. This is the character configured by 'stty erase'. If
--   the call to <tt>tcgetattr</tt> fails, this will return <a>Nothing</a>.
--   Otherwise it will return the character that has been configured to
--   indicate the canonical mode ERASE behavior. That character can then be
--   added to the table of strings that we interpret to mean Backspace.
--   
--   For more details, see:
--   
--   <ul>
--   
--   <li><a>https://www.gnu.org/software/libc/manual/html_node/Canonical-or-Not.html</a></li>
--   
--   <li><a>https://www.gsp.com/cgi-bin/man.cgi?section=1&amp;topic=stty</a></li>
--   
--   <li><a>https://github.com/matterhorn-chat/matterhorn/issues/565</a></li>
--   </ul>
getTtyEraseChar :: Fd -> IO (Maybe Char)
currentTerminalName :: IO (Maybe String)
vtyConfigPath :: IO FilePath
widthTableFilename :: String -> String
vtyDataDirectory :: IO FilePath
terminalWidthTablePath :: IO (Maybe FilePath)
vtyConfigFileEnvName :: String
data ConfigUpdateResult
ConfigurationCreated :: ConfigUpdateResult
ConfigurationModified :: ConfigUpdateResult
ConfigurationConflict :: String -> ConfigUpdateResult
ConfigurationRedundant :: ConfigUpdateResult

-- | Add a <tt>widthMap</tt> directive to the Vty configuration file at the
--   specified path.
--   
--   If the configuration path refers to a configuration that already
--   contains the directive for the specified map and terminal type, the
--   configuration file will not be modified. If the file does not contain
--   the directive, it will be appended to the file.
--   
--   If the configuration path does not exist, a new configuration file
--   will be created and any directories in the path will also be created.
--   
--   This returns <tt>True</tt> if the configuration was created or
--   modified and <tt>False</tt> otherwise. This does not handle exceptions
--   raised by file or directory permissions issues.
addConfigWidthMap :: FilePath -> String -> FilePath -> IO ConfigUpdateResult
instance GHC.Classes.Eq Graphics.Vty.Config.VtyConfigurationError
instance GHC.Show.Show Graphics.Vty.Config.VtyConfigurationError
instance GHC.Classes.Eq Graphics.Vty.Config.Config
instance GHC.Show.Show Graphics.Vty.Config.Config
instance GHC.Show.Show Graphics.Vty.Config.ConfigUpdateResult
instance GHC.Classes.Eq Graphics.Vty.Config.ConfigUpdateResult
instance Graphics.Vty.Config.GParseAlts f => Graphics.Vty.Config.GParse (GHC.Generics.M1 GHC.Generics.D i f)
instance (GHC.Generics.Constructor i, Graphics.Vty.Config.GParse f) => Graphics.Vty.Config.GParseAlts (GHC.Generics.M1 GHC.Generics.C i f)
instance (Graphics.Vty.Config.GParseAlts f, Graphics.Vty.Config.GParseAlts g) => Graphics.Vty.Config.GParseAlts (f GHC.Generics.:+: g)
instance Graphics.Vty.Config.GParseAlts GHC.Generics.V1
instance Graphics.Vty.Config.GParse f => Graphics.Vty.Config.GParse (GHC.Generics.M1 GHC.Generics.S i f)
instance Graphics.Vty.Config.GParse GHC.Generics.U1
instance Graphics.Vty.Config.Parse a => Graphics.Vty.Config.GParse (GHC.Generics.K1 i a)
instance (Graphics.Vty.Config.GParse f, Graphics.Vty.Config.GParse g) => Graphics.Vty.Config.GParse (f GHC.Generics.:*: g)
instance Graphics.Vty.Config.Parse GHC.Types.Char
instance Graphics.Vty.Config.Parse GHC.Types.Int
instance Graphics.Vty.Config.Parse Graphics.Vty.Input.Events.Key
instance Graphics.Vty.Config.Parse Graphics.Vty.Input.Events.Modifier
instance Graphics.Vty.Config.Parse a => Graphics.Vty.Config.Parse [a]
instance GHC.Base.Semigroup Graphics.Vty.Config.Config
instance GHC.Base.Monoid Graphics.Vty.Config.Config
instance GHC.Exception.Type.Exception Graphics.Vty.Config.VtyConfigurationError

module Graphics.Vty.Input.Focus

-- | These sequences set xterm-based terminals to send focus event
--   sequences.
requestFocusEvents :: String

-- | These sequences disable focus events.
disableFocusEvents :: String

-- | Does the specified string begin with a focus event?
isFocusEvent :: String -> Bool

-- | Attempt to classify an input string as a focus event.
classifyFocusEvent :: String -> KClass


-- | This module provides parsers for mouse events for both "normal" and
--   "extended" modes. This implementation was informed by
--   
--   
--   <a>http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Mouse-Tracking</a>
module Graphics.Vty.Input.Mouse

-- | These sequences set xterm-based terminals to send mouse event
--   sequences.
requestMouseEvents :: String

-- | These sequences disable mouse events.
disableMouseEvents :: String

-- | Does the specified string begin with a mouse event?
isMouseEvent :: String -> Bool

-- | Attempt to lassify an input string as a mouse event.
classifyMouseEvent :: String -> KClass


-- | This module provides bracketed paste support as described at
--   
--   <a>http://cirw.in/blog/bracketed-paste</a>
module Graphics.Vty.Input.Paste

-- | Parse a bracketed paste. This should only be called on a string if
--   both <a>bracketedPasteStarted</a> and <a>bracketedPasteFinished</a>
--   return <a>True</a>.
parseBracketedPaste :: String -> KClass

-- | Does the input start a bracketed paste?
bracketedPasteStarted :: String -> Bool

-- | Does the input contain a complete bracketed paste?
bracketedPasteFinished :: String -> Bool

module Graphics.Vty.Input.Terminfo

-- | Queries the terminal for all capability-based input sequences and then
--   adds on a terminal-dependent input sequence mapping.
--   
--   For reference see:
--   
--   <ul>
--   <li><a>http://vimdoc.sourceforge.net/htmldoc/term.html</a></li>
--   <li>vim74<i>src</i>term.c</li>
--   <li><a>http://invisible-island.net/vttest/</a></li>
--   
--   <li><a>http://aperiodic.net/phil/archives/Geekery/term-function-keys.html</a></li>
--   </ul>
--   
--   Terminfo is incomplete. The vim source implies that terminfo is also
--   incorrect. Vty assumes that the internal terminfo table added to the
--   system-provided terminfo table is correct.
--   
--   The procedure used here is:
--   
--   <ol>
--   <li>Build terminfo table for all caps. Missing caps are not
--   added.</li>
--   <li>Add tables for visible chars, esc, del, ctrl, and meta.</li>
--   <li>Add internally-defined table for given terminal type.</li>
--   </ol>
--   
--   Precedence is currently implicit in the <tt>compile</tt> algorithm.
classifyMapForTerm :: String -> Terminal -> ClassifyMap

-- | The key table applicable to all terminals.
--   
--   Note that some of these entries are probably only applicable to
--   ANSI/VT100 terminals.
universalTable :: ClassifyMap
capsClassifyMap :: Terminal -> [(String, Event)] -> ClassifyMap

-- | Tables specific to a given terminal that are not derivable from
--   terminfo.
--   
--   Note that this adds the ANSI<i>VT100</i>VT50 tables regardless of term
--   identifier.
termSpecificTables :: String -> [ClassifyMap]

-- | Visible characters in the ISO-8859-1 and UTF-8 common set.
--   
--   We limit to &lt; 0xC1. The UTF8 sequence detector will catch all
--   values 0xC2 and above before this classify table is reached.
visibleChars :: ClassifyMap

-- | Non-printable characters in the ISO-8859-1 and UTF-8 common set
--   translated to ctrl + char.
--   
--   This treats CTRL-i the same as tab.
ctrlChars :: ClassifyMap

-- | Ctrl+Meta+Char
ctrlMetaChars :: ClassifyMap

-- | Esc, meta-esc, delete, meta-delete, enter, meta-enter.
specialSupportKeys :: ClassifyMap

-- | A classification table directly generated from terminfo cap strings.
--   These are:
--   
--   <ul>
--   <li>ka1 - keypad up-left</li>
--   <li>ka3 - keypad up-right</li>
--   <li>kb2 - keypad center</li>
--   <li>kbs - keypad backspace</li>
--   <li>kbeg - begin</li>
--   <li>kcbt - back tab</li>
--   <li>kc1 - keypad left-down</li>
--   <li>kc3 - keypad right-down</li>
--   <li>kdch1 - delete</li>
--   <li>kcud1 - down</li>
--   <li>kend - end</li>
--   <li>kent - enter</li>
--   <li>kf0 - kf63 - function keys</li>
--   <li>khome - KHome</li>
--   <li>kich1 - insert</li>
--   <li>kcub1 - left</li>
--   <li>knp - next page (page down)</li>
--   <li>kpp - previous page (page up)</li>
--   <li>kcuf1 - right</li>
--   <li>kDC - shift delete</li>
--   <li>kEND - shift end</li>
--   <li>kHOM - shift home</li>
--   <li>kIC - shift insert</li>
--   <li>kLFT - shift left</li>
--   <li>kRIT - shift right</li>
--   <li>kcuu1 - up</li>
--   </ul>
keysFromCapsTable :: ClassifyMap

-- | Cap names for function keys.
functionKeyCapsTable :: ClassifyMap


-- | This module provides the input layer for Vty, including methods for
--   initializing an <a>Input</a> structure and reading <a>Event</a>s from
--   the terminal.
--   
--   Note that due to the evolution of terminal emulators, some keys and
--   combinations will not reliably map to the expected events by any
--   terminal program. There is no 1:1 mapping from key events to bytes
--   read from the terminal input device. In very limited cases the
--   terminal and vty's input process can be customized to resolve these
--   issues; see <a>Graphics.Vty.Config</a> for how to configure vty's
--   input processing.
--   
--   <h1>VTY's Implementation</h1>
--   
--   There are two input modes:
--   
--   <ol>
--   <li>7-bit</li>
--   <li>8-bit</li>
--   </ol>
--   
--   The 7-bit input mode is the default and the expected mode in most use
--   cases. This is what Vty uses.
--   
--   <h2>7-bit input encoding</h2>
--   
--   Control key combinations are represented by masking the two high bits
--   of the 7-bit input. Historically the control key actually grounded the
--   two high bit wires: 6 and 7. This is why control key combos map to
--   single character events: the input bytes are identical. The input byte
--   is the bit encoding of the character with bits 6 and 7 masked. Bit 6
--   is set by shift. Bit 6 and 7 are masked by control. For example,
--   
--   <ul>
--   <li>Control-I is <tt>i</tt>, `01101001`, and has bit 6 and 7 masked to
--   become `00001001`, which is the ASCII and UTF-8 encoding of the Tab
--   key.</li>
--   <li>Control+Shift-C is <tt>C</tt>, `01000011`, with bit 6 and 7 set to
--   zero which is `0000011` and is the "End of Text" code.</li>
--   <li>Hypothesis: This is why capital-A, <tt>A</tt>, has value 65 in
--   ASCII: this is the value 1 with bit 7 set and 6 unset.</li>
--   <li>Hypothesis: Bit 6 is unset by upper case letters because,
--   initially, there were only upper case letters used and a 5 bit
--   encoding.</li>
--   </ul>
--   
--   <h2>8-bit encoding</h2>
--   
--   The 8th bit was originally used for parity checking which is useless
--   for terminal emulators. Some terminal emulators support an 8-bit input
--   encoding. While this provides some advantages, the actual usage is
--   low. Most systems use 7-bit mode but recognize 8-bit control
--   characters when escaped. This is what Vty does.
--   
--   <h2>Escaped Control Keys</h2>
--   
--   Using 7-bit input encoding, the <tt>ESC</tt> byte can signal the start
--   of an encoded control key. To differentiate a single <tt>ESC</tt>
--   event from a control key, the timing of the input is used.
--   
--   <ol>
--   <li><tt>ESC</tt> individually: <tt>ESC</tt> byte; no bytes following
--   for a period of <tt>VMIN</tt> milliseconds.</li>
--   <li>Control keys that contain <tt>ESC</tt> in their encoding: The @ESC
--   byte is followed by more bytes read within <tt>VMIN</tt> milliseconds.
--   All bytes up until the next valid input block are passed to the
--   classifier.</li>
--   </ol>
--   
--   If the current runtime is the threaded runtime then the terminal's
--   <tt>VMIN</tt> and <tt>VTIME</tt> behavior reliably implement the above
--   rules. If the current runtime does not support <tt>forkOS</tt> then
--   there is currently no implementation.
--   
--   <h2>Unicode Input and Escaped Control Key Sequences</h2>
--   
--   The input encoding determines how UTF-8 encoded characters are
--   recognized.
--   
--   <ul>
--   <li>7-bit mode: UTF-8 can be input unambiguiously. UTF-8 input is a
--   superset of ASCII. UTF-8 does not overlap escaped control key
--   sequences. However, the escape key must be differentiated from escaped
--   control key sequences by the timing of the input bytes.</li>
--   <li>8-bit mode: UTF-8 cannot be input unambiguously. This does not
--   require using the timing of input bytes to differentiate the escape
--   key. Many terminals do not support 8-bit mode.</li>
--   </ul>
--   
--   <h2>Terminfo</h2>
--   
--   The terminfo system is used to determine how some keys are encoded.
--   Terminfo is incomplete and in some cases terminfo is incorrect. Vty
--   assumes terminfo is correct but provides a mechanism to override
--   terminfo; see <a>Graphics.Vty.Config</a>, specifically
--   <tt>inputOverrides</tt>.
--   
--   <h2>Terminal Input is Broken</h2>
--   
--   Clearly terminal input has fundemental issues. There is no easy way to
--   reliably resolve these issues.
--   
--   One resolution would be to ditch standard terminal interfaces entirely
--   and just go directly to scancodes. This would be a reasonable option
--   for Vty if everybody used the linux kernel console but for obvious
--   reasons this is not possible.
--   
--   The <a>Graphics.Vty.Config</a> module supports customizing the
--   input-byte-to-event mapping and xterm supports customizing the
--   scancode-to-input-byte mapping. With a lot of work a user's system can
--   be set up to encode all the key combos in an almost-sane manner.
--   
--   <h2>See also</h2>
--   
--   <ul>
--   <li><a>http://www.leonerd.org.uk/hacks/fixterms/</a></li>
--   </ul>
module Graphics.Vty.Input

-- | Representations of non-modifier keys.
--   
--   <ul>
--   <li>KFun is indexed from 0 to 63. Range of supported FKeys varies by
--   terminal and keyboard.</li>
--   <li>KUpLeft, KUpRight, KDownLeft, KDownRight, KCenter support varies
--   by terminal and keyboard.</li>
--   <li>Actually, support for most of these but KEsc, KChar, KBS, and
--   KEnter vary by terminal and keyboard.</li>
--   </ul>
data Key
KEsc :: Key
KChar :: Char -> Key
KBS :: Key
KEnter :: Key
KLeft :: Key
KRight :: Key
KUp :: Key
KDown :: Key
KUpLeft :: Key
KUpRight :: Key
KDownLeft :: Key
KDownRight :: Key
KCenter :: Key
KFun :: Int -> Key
KBackTab :: Key
KPrtScr :: Key
KPause :: Key
KIns :: Key
KHome :: Key
KPageUp :: Key
KDel :: Key
KEnd :: Key
KPageDown :: Key
KBegin :: Key
KMenu :: Key

-- | Modifier keys. Key codes are interpreted such that users are more
--   likely to have Meta than Alt; for instance on the PC Linux console,
--   <a>MMeta</a> will generally correspond to the physical Alt key.
data Modifier
MShift :: Modifier
MCtrl :: Modifier
MMeta :: Modifier
MAlt :: Modifier

-- | Mouse buttons.
data Button
BLeft :: Button
BMiddle :: Button
BRight :: Button
BScrollUp :: Button
BScrollDown :: Button

-- | Events.
data Event

-- | A keyboard key was pressed with the specified modifiers.
EvKey :: Key -> [Modifier] -> Event

-- | A mouse button was pressed at the specified column and row. Any
--   modifiers available in the event are also provided.
EvMouseDown :: Int -> Int -> Button -> [Modifier] -> Event

-- | A mouse button was released at the specified column and row. Some
--   terminals report only that a button was released without specifying
--   which one; in that case, Nothing is provided. Otherwise Just the
--   button released is included in the event.
EvMouseUp :: Int -> Int -> Maybe Button -> Event

-- | If read from <tt>eventChannel</tt> this is the size at the time of the
--   signal. If read from <tt>nextEvent</tt> this is the size at the time
--   the event was processed by Vty. Typically these are the same, but if
--   somebody is resizing the terminal quickly they can be different.
EvResize :: Int -> Int -> Event

-- | A paste event occurs when a bracketed paste input sequence is
--   received. For terminals that support bracketed paste mode, these
--   events will be triggered on a paste event. Terminals that do not
--   support bracketed pastes will send the paste contents as ordinary
--   input (which is probably bad, so beware!) Note that the data is
--   provided in raw form and you'll have to decode (e.g. as UTF-8) if
--   that's what your application expects.
EvPaste :: ByteString -> Event

-- | The terminal running the application lost input focus.
EvLostFocus :: Event

-- | The terminal running the application gained input focus.
EvGainedFocus :: Event
data Input
Input :: TChan Event -> IO () -> IO () -> IORef Config -> Maybe Handle -> Input

-- | Channel of events direct from input processing. Unlike
--   <tt>nextEvent</tt> this will not refresh the display if the next event
--   is an <a>EvResize</a>.
[_eventChannel] :: Input -> TChan Event

-- | Shuts down the input processing. As part of shutting down the input,
--   this should also restore the input state.
[shutdownInput] :: Input -> IO ()

-- | Restore the terminal's input state to what it was prior to configuring
--   input for Vty. This should be done as part of <a>shutdownInput</a> but
--   is exposed in case you need to access it directly.
[restoreInputState] :: Input -> IO ()

-- | Changes to this value are reflected after the next event.
[_configRef] :: Input -> IORef Config

-- | input debug log
[_inputDebug] :: Input -> Maybe Handle

-- | Set up the terminal with file descriptor <a>inputFd</a> for input.
--   Returns an <a>Input</a>.
--   
--   The table used to determine the <tt>Events</tt> to produce for the
--   input bytes comes from <a>classifyMapForTerm</a> which is then
--   overridden by the the applicable entries from the configuration's
--   <a>inputMap</a>.
--   
--   The terminal device's mode flags are configured by the
--   <a>attributeControl</a> function.
inputForConfig :: Config -> IO Input

module Graphics.Vty.Picture

-- | A Vty picture.
--   
--   These can be constructed directly or using <a>picForImage</a>.
data Picture
Picture :: Cursor -> [Image] -> Background -> Picture

-- | The picture's cursor.
[picCursor] :: Picture -> Cursor

-- | The picture's image layers (top-most first).
[picLayers] :: Picture -> [Image]

-- | The picture's background to be displayed in locations with no Image
--   data.
[picBackground] :: Picture -> Background

-- | A picture can be configured to hide the cursor or to show the cursor
--   at the specified character position.
--   
--   There is not a 1:1 map from character positions to a row and column on
--   the screen due to characters that take more than 1 column.
data Cursor

-- | Hide the cursor
NoCursor :: Cursor

-- | Show the cursor at the given logical column accounting for character
--   width in the presence of multi-column characters.
Cursor :: !Int -> !Int -> Cursor

-- | Show the cursor at the given absolute terminal column and row
AbsoluteCursor :: !Int -> !Int -> Cursor

-- | A <a>Picture</a> has a background pattern. The background is either:
--   
--   <ul>
--   <li>ClearBackground, which shows the layer below or is blank if the
--   bottom layer</li>
--   <li>A character and a display attribute</li>
--   </ul>
--   
--   If the display attribute used previously should be used for a
--   background fill then use <a>currentAttr</a> for the background
--   attribute.
data Background
Background :: Char -> Attr -> Background
[backgroundChar] :: Background -> Char
[backgroundAttr] :: Background -> Attr

-- | A ClearBackground is:
--   
--   <ul>
--   <li>the space character if there are remaining non-skip ops</li>
--   <li>End of line if there are no remaining non-skip ops.</li>
--   </ul>
ClearBackground :: Background

-- | A picture with no cursor, background or image layers.
emptyPicture :: Picture

-- | Add an <a>Image</a> as the top-most layer of a <a>Picture</a>.
addToTop :: Picture -> Image -> Picture

-- | Add an <a>Image</a> as the bottom-most layer of a <a>Picture</a>.
addToBottom :: Picture -> Image -> Picture

-- | Create a picture from the given image. The picture will not have a
--   displayed cursor and no background pattern (ClearBackground) will be
--   used.
picForImage :: Image -> Picture

-- | Create a picture with the given layers, top-most first.
--   
--   The picture will not have a displayed cursor and no background pattern
--   (ClearBackgroun) will be used.
picForLayers :: [Image] -> Picture

-- | Return the top-most <a>Image</a> layer for a picture. This is unsafe
--   for <a>Picture</a>s without at least one layer.
--   
--   This is provided for compatibility with applications that do not use
--   more than a single layer.
picImage :: Picture -> Image
instance GHC.Classes.Eq Graphics.Vty.Picture.Cursor
instance GHC.Classes.Eq Graphics.Vty.Picture.Background
instance GHC.Classes.Eq Graphics.Vty.Picture.Picture
instance GHC.Show.Show Graphics.Vty.Picture.Picture
instance Control.DeepSeq.NFData Graphics.Vty.Picture.Picture
instance Control.DeepSeq.NFData Graphics.Vty.Picture.Background
instance Control.DeepSeq.NFData Graphics.Vty.Picture.Cursor


-- | A picture is translated into a sequences of state changes and
--   character spans. The attribute is applied to all following spans,
--   including spans of the next row. The nth element of the sequence
--   represents the nth row (from top to bottom) of the picture to render.
--   
--   A span op sequence will be defined for all rows and columns (and no
--   more) of the region provided with the picture to <tt>spansForPic</tt>.
module Graphics.Vty.Span

-- | This represents an operation on the terminal: either an attribute
--   change or the output of a text string.
data SpanOp

-- | A span of UTF-8 text occupies a specific number of screen space
--   columns. A single UTF character does not necessarily represent 1
--   colunm. See Codec.Binary.UTF8.Width TextSpan [Attr] [output width in
--   columns] [number of characters] [data]
TextSpan :: !Attr -> !Int -> !Int -> DisplayText -> SpanOp
[textSpanAttr] :: SpanOp -> !Attr
[textSpanOutputWidth] :: SpanOp -> !Int
[textSpanCharWidth] :: SpanOp -> !Int
[textSpanText] :: SpanOp -> DisplayText

-- | Skips the given number of columns.
Skip :: !Int -> SpanOp

-- | Marks the end of a row. Specifies how many columns are remaining.
--   These columns will not be explicitly overwritten with the span ops.
--   The terminal is require to assure the remaining columns are clear.
RowEnd :: !Int -> SpanOp

-- | A vector of span operations executed in succession. This represents
--   the operations required to render a row of the terminal. The
--   operations in one row may affect subsequent rows. For example, setting
--   the foreground color in one row will affect all subsequent rows until
--   the foreground color is changed.
type SpanOps = Vector SpanOp
dropOps :: Int -> SpanOps -> SpanOps
splitOpsAt :: Int -> SpanOps -> (SpanOps, SpanOps)

-- | A vector of span operation vectors for display, one per row of the
--   output region.
type DisplayOps = Vector SpanOps

-- | The number of columns the DisplayOps are defined for.
--   
--   All spans are verified to define same number of columns.
displayOpsColumns :: DisplayOps -> Int

-- | The number of rows the DisplayOps are defined for.
displayOpsRows :: DisplayOps -> Int
affectedRegion :: DisplayOps -> DisplayRegion

-- | The number of columns a SpanOps affects.
spanOpsAffectedColumns :: SpanOps -> Int

-- | The width of a single SpanOp in columns.
spanOpHasWidth :: SpanOp -> Maybe (Int, Int)

-- | The number of columns to the character at the given position in the
--   span op.
columnsToCharOffset :: Int -> SpanOp -> Int
instance GHC.Classes.Eq Graphics.Vty.Span.SpanOp
instance GHC.Show.Show Graphics.Vty.Span.SpanOp


-- | Transforms an image into rows of operations.
module Graphics.Vty.PictureToSpans
type MRowOps s = MVector s SpanOps
type MSpanOps s = MVector s SpanOp
data BlitState
BlitState :: Int -> Int -> Int -> Int -> Int -> Int -> BlitState
[_columnOffset] :: BlitState -> Int
[_rowOffset] :: BlitState -> Int
[_skipColumns] :: BlitState -> Int
[_skipRows] :: BlitState -> Int
[_remainingColumns] :: BlitState -> Int
[_remainingRows] :: BlitState -> Int
skipRows :: Lens' BlitState Int
skipColumns :: Lens' BlitState Int
rowOffset :: Lens' BlitState Int
remainingRows :: Lens' BlitState Int
remainingColumns :: Lens' BlitState Int
columnOffset :: Lens' BlitState Int
data BlitEnv s
BlitEnv :: DisplayRegion -> MRowOps s -> BlitEnv s
[_region] :: BlitEnv s -> DisplayRegion
[_mrowOps] :: BlitEnv s -> MRowOps s
region :: forall s_a1k65. Lens' (BlitEnv s_a1k65) DisplayRegion
mrowOps :: forall s_a1k65 s_a1k8f. Lens (BlitEnv s_a1k65) (BlitEnv s_a1k8f) (MRowOps s_a1k65) (MRowOps s_a1k8f)
type BlitM s a = ReaderT (BlitEnv s) (StateT BlitState (ST s)) a

-- | Produces the span ops that will render the given picture, possibly
--   cropped or padded, into the specified region.
displayOpsForPic :: Picture -> DisplayRegion -> DisplayOps

-- | Returns the DisplayOps for an image rendered to a window the size of
--   the image.
--   
--   largerly used only for debugging.
displayOpsForImage :: Image -> DisplayOps

-- | Produces the span ops for each layer then combines them.
combinedOpsForLayers :: Picture -> DisplayRegion -> ST s (MRowOps s)
substituteSkips :: Background -> MRowOps s -> ST s (MRowOps s)
mergeUnder :: MRowOps s -> MRowOps s -> ST s (MRowOps s)
mergeRowUnder :: SpanOps -> SpanOps -> SpanOps
swapSkipsForSingleColumnCharSpan :: Char -> Attr -> SpanOps -> SpanOps
swapSkipsForCharSpan :: Int -> Char -> Attr -> SpanOps -> SpanOps

-- | Builds a vector of row operations that will output the given picture
--   to the terminal.
--   
--   Crops to the given display region.
buildSpans :: Image -> DisplayRegion -> ST s (MRowOps s)

-- | Add the operations required to build a given image to the current set
--   of row operations.
startImageBuild :: Image -> BlitM s ()
isOutOfBounds :: Image -> BlitState -> Bool

-- | This adds an image that might be partially clipped to the output ops.
--   
--   This is a very touchy algorithm. Too touchy. For instance, the
--   CropRight and CropBottom implementations are odd. They pass the
--   current tests but something seems terribly wrong about all this.
addMaybeClipped :: forall s. Image -> BlitM s ()
addMaybeClippedJoin :: forall s. String -> Lens BlitState BlitState Int Int -> Lens BlitState BlitState Int Int -> Lens BlitState BlitState Int Int -> Int -> Image -> Image -> Int -> BlitM s ()
addUnclippedText :: Attr -> DisplayText -> BlitM s ()
addRowCompletion :: DisplayRegion -> Int -> BlitM s ()

-- | snocs the operation to the operations for the given row.
snocOp :: SpanOp -> Int -> BlitM s ()


-- | This module provides an abstract interface for performing terminal
--   output. The only user-facing part of this API is <a>Output</a>.
module Graphics.Vty.Output.Interface

-- | The Vty terminal output interface.
data Output
Output :: String -> IO () -> IO () -> IO () -> ((Int, Int) -> IO ()) -> IO DisplayRegion -> (ByteString -> IO ()) -> Int -> Bool -> (Mode -> Bool) -> (Mode -> Bool -> IO ()) -> (Mode -> IO Bool) -> IORef AssumedState -> (Output -> DisplayRegion -> IO DisplayContext) -> IO () -> IO Bool -> IO Bool -> IO Bool -> Output

-- | Text identifier for the output device. Used for debugging.
[terminalID] :: Output -> String

-- | Release the terminal just prior to application exit and reset it to
--   its state prior to application startup.
[releaseTerminal] :: Output -> IO ()

-- | Clear the display and initialize the terminal to some initial display
--   state.
--   
--   The expectation of a program is that the display starts in some The
--   initial state. initial state would consist of fixed values:
--   
--   <ul>
--   <li>cursor at top left</li>
--   <li>UTF-8 character encoding</li>
--   <li>drawing characteristics are the default</li>
--   </ul>
[reserveDisplay] :: Output -> IO ()

-- | Return the display to the state before <a>reserveDisplay</a> If no
--   previous state then set the display state to the initial state.
[releaseDisplay] :: Output -> IO ()

-- | Sets the current display bounds (width, height).
[setDisplayBounds] :: Output -> (Int, Int) -> IO ()

-- | Returns the current display bounds.
[displayBounds] :: Output -> IO DisplayRegion

-- | Output the bytestring to the terminal device.
[outputByteBuffer] :: Output -> ByteString -> IO ()

-- | Specifies the maximum number of colors supported by the context.
[contextColorCount] :: Output -> Int

-- | Specifies whether the cursor can be shown / hidden.
[supportsCursorVisibility] :: Output -> Bool

-- | Indicates support for terminal modes for this output device.
[supportsMode] :: Output -> Mode -> Bool

-- | Enables or disables a mode (does nothing if the mode is unsupported).
[setMode] :: Output -> Mode -> Bool -> IO ()

-- | Returns whether a mode is enabled.
[getModeStatus] :: Output -> Mode -> IO Bool
[assumedStateRef] :: Output -> IORef AssumedState

-- | Acquire display access to the given region of the display. Currently
--   all regions have the upper left corner of (0,0) and the lower right
--   corner at (max displayWidth providedWidth, max displayHeight
--   providedHeight)
[mkDisplayContext] :: Output -> Output -> DisplayRegion -> IO DisplayContext

-- | Ring the terminal bell if supported.
[ringTerminalBell] :: Output -> IO ()

-- | Returns whether the terminal has an audio bell feature.
[supportsBell] :: Output -> IO Bool

-- | Returns whether the terminal supports italicized text.
--   
--   This is terminal-dependent and should make a best effort to determine
--   whether this feature is supported, but even if the terminal advertises
--   support (e.g. via terminfo) that might not be a reliable indicator of
--   whether the feature will work as desired.
[supportsItalics] :: Output -> IO Bool

-- | Returns whether the terminal supports strikethrough text.
--   
--   This is terminal-dependent and should make a best effort to determine
--   whether this feature is supported, but even if the terminal advertises
--   support (e.g. via terminfo) that might not be a reliable indicator of
--   whether the feature will work as desired.
[supportsStrikethrough] :: Output -> IO Bool
data AssumedState
AssumedState :: Maybe FixedAttr -> Maybe DisplayOps -> AssumedState
[prevFattr] :: AssumedState -> Maybe FixedAttr
[prevOutputOps] :: AssumedState -> Maybe DisplayOps
data DisplayContext
DisplayContext :: Output -> DisplayRegion -> (Int -> Int -> Write) -> Write -> Write -> (Bool -> FixedAttr -> Attr -> DisplayAttrDiff -> Write) -> (Bool -> Write) -> Write -> IO () -> DisplayContext
[contextDevice] :: DisplayContext -> Output

-- | Provide the bounds of the display context.
[contextRegion] :: DisplayContext -> DisplayRegion

-- | Sets the output position to the specified row and column where the
--   number of bytes required for the control codes can be specified
--   seperate from the actual byte sequence.
[writeMoveCursor] :: DisplayContext -> Int -> Int -> Write
[writeShowCursor] :: DisplayContext -> Write
[writeHideCursor] :: DisplayContext -> Write
[writeSetAttr] :: DisplayContext -> Bool -> FixedAttr -> Attr -> DisplayAttrDiff -> Write

-- | Reset the display attributes to the default display attributes.
[writeDefaultAttr] :: DisplayContext -> Bool -> Write
[writeRowEnd] :: DisplayContext -> Write

-- | See <a>inlineHack</a>
[inlineHack] :: DisplayContext -> IO ()

-- | Modal terminal features that can be enabled and disabled.
data Mode

-- | Mouse mode (whether the terminal is configured to provide mouse input
--   events)
Mouse :: Mode

-- | Paste mode (whether the terminal is configured to provide events on OS
--   pastes)
BracketedPaste :: Mode

-- | Focus-in/focus-out events (whether the terminal is configured to
--   provide events on focus change)
Focus :: Mode

-- | Hyperlink mode via the <a>withURL</a> attribute modifier (see
--   <a>https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda)</a>.
--   Note that this may not work gracefully in all terminal emulators so be
--   sure to test this mode with the terminals you intend to support. It is
--   off by default.
Hyperlink :: Mode
displayContext :: Output -> DisplayRegion -> IO DisplayContext

-- | Displays the given <a>Picture</a>.
--   
--   <ol>
--   <li>The image is cropped to the display size.</li>
--   <li>Converted into a sequence of attribute changes and text
--   spans.</li>
--   <li>The cursor is hidden.</li>
--   <li>Serialized to the display.</li>
--   <li>The cursor is then shown and positioned or kept hidden.</li>
--   </ol>
outputPicture :: DisplayContext -> Picture -> IO ()
initialAssumedState :: AssumedState

-- | Not all terminals support all display attributes. This filters a
--   display attribute to what the given terminal can display.
limitAttrForDisplay :: Output -> Attr -> Attr
instance GHC.Show.Show Graphics.Vty.Output.Interface.Mode
instance GHC.Read.Read Graphics.Vty.Output.Interface.Mode
instance GHC.Classes.Eq Graphics.Vty.Output.Interface.Mode


-- | Terminfo-based terminal output driver.
--   
--   Copyright Corey O'Connor (coreyoconnor@gmail.com)
module Graphics.Vty.Output.TerminfoBased

-- | Constructs an output driver that uses terminfo for all control codes.
--   While this should provide the most compatible terminal, terminfo does
--   not support some features that would increase efficiency and improve
--   compatibility:
--   
--   <ul>
--   <li>determining the character encoding supported by the terminal.
--   Should this be taken from the LANG environment variable?</li>
--   <li>Providing independent string capabilities for all display
--   attributes.</li>
--   </ul>
reserveTerminal :: String -> Fd -> IO Output
setWindowSize :: Fd -> (Int, Int) -> IO ()


-- | Xterm output driver. This uses the Terminfo driver with some
--   extensions for Xterm.
module Graphics.Vty.Output.XTermColor

-- | Construct an Xterm output driver. Initialize the display to UTF-8.
reserveTerminal :: (Applicative m, MonadIO m) => String -> Fd -> m Output


-- | This provides a mock terminal implementation that is nice for testing.
--   This transforms the output operations to visible characters which is
--   useful for testing.
module Graphics.Vty.Output.Mock
type MockData = IORef (UTF8 ByteString)

-- | The mock display terminal produces a string representation of the
--   requested picture. There is *not* an isomorphism between the string
--   representation and the picture. The string representation is a
--   simplification of the picture that is only useful in debugging VTY
--   without considering terminal specific issues.
--   
--   The mock implementation is useful in manually determining if the
--   sequence of terminal operations matche the expected sequence. The
--   requirement of the produced representation is simplicity in parsing
--   the text representation and determining how the picture was mapped to
--   terminal operations.
--   
--   The string representation is a sequence of identifiers where each
--   identifier is the name of an operation in the algebra.
mockTerminal :: (Applicative m, MonadIO m) => DisplayRegion -> m (MockData, Output)


-- | This module provides functions for accessing the current terminal or a
--   specific terminal device.
--   
--   See also:
--   
--   <ol>
--   <li><a>Graphics.Vty.Output</a>: This instantiates an abtract interface
--   to the terminal based on the <tt>TERM</tt> and <tt>COLORTERM</tt>
--   environment variables.</li>
--   <li><a>Graphics.Vty.Output.Interface</a>: Defines the generic
--   interface all terminal modules need to implement.</li>
--   <li><a>Graphics.Vty.Output.TerminfoBased</a>: Defines a terminal
--   instance that uses terminfo for all control strings. No attempt is
--   made to change the character set to UTF-8 for these terminals.</li>
--   <li><a>Graphics.Vty.Output.XTermColor</a>: This module contains an
--   interface suitable for xterm-like terminals. These are the terminals
--   where <tt>TERM</tt> begins with <tt>xterm</tt>. This does use terminfo
--   for as many control codes as possible.</li>
--   </ol>
module Graphics.Vty.Output

-- | Returns an <a>Output</a> for the terminal specified in <a>Config</a>.
--   
--   The specific Output implementation used is hidden from the API user.
--   All terminal implementations are assumed to perform more, or less, the
--   same. Currently, all implementations use terminfo for at least some
--   terminal specific information.
--   
--   If a terminal implementation is developed for a terminal without
--   terminfo support then Vty should work as expected on that terminal.
--   
--   Selection of a terminal is done as follows:
--   
--   <ul>
--   <li>If TERM contains "xterm" or "screen", use XTermColor.</li>
--   <li>otherwise use the TerminfoBased driver.</li>
--   </ul>
outputForConfig :: Config -> IO Output

-- | Sets the cursor position to the given output column and row.
--   
--   This is not necessarially the same as the character position with the
--   same coordinates. Characters can be a variable number of columns in
--   width.
--   
--   Currently, the only way to set the cursor position to a given
--   character coordinate is to specify the coordinate in the Picture
--   instance provided to <a>outputPicture</a> or <tt>refresh</tt>.
setCursorPos :: Output -> Int -> Int -> IO ()

-- | Hides the cursor.
hideCursor :: Output -> IO ()

-- | Shows the cursor.
showCursor :: Output -> IO ()

module Graphics.Vty.Debug
data MockWindow
MockWindow :: Int -> Int -> MockWindow
data SpanConstructEvent
SpanSetAttr :: Attr -> SpanConstructEvent
type SpanConstructLog = [SpanConstructEvent]
rowOpsAffectedColumns :: DisplayOps -> [Int]
allSpansHaveWidth :: DisplayOps -> Int -> Bool
spanOpsAffectedRows :: DisplayOps -> Int
isSetAttr :: Attr -> SpanConstructEvent -> Bool
regionForWindow :: MockWindow -> DisplayRegion
type ImageConstructLog = [ImageConstructEvent]
data ImageConstructEvent
ImageConstructEvent :: ImageConstructEvent
forwardImageOps :: [Image -> Image]
forwardTransform :: ImageOp -> Image -> Image
reverseTransform :: ImageOp -> Image -> Image
data ImageOp
ImageOp :: ImageEndo -> ImageEndo -> ImageOp
type ImageEndo = Image -> Image
debugImageOps :: [ImageOp]
idImageOp :: ImageOp
instance GHC.Classes.Eq Graphics.Vty.Debug.MockWindow
instance GHC.Show.Show Graphics.Vty.Debug.MockWindow

module Graphics.Vty.UnicodeWidthTable.Types

-- | A run-length-encoded table of Unicode character widths.
data UnicodeWidthTable
UnicodeWidthTable :: [WidthTableRange] -> UnicodeWidthTable

-- | The ranges in the table.
[unicodeWidthTableRanges] :: UnicodeWidthTable -> [WidthTableRange]

-- | A range of code points in a width table.
data WidthTableRange
WidthTableRange :: Word32 -> Word32 -> Word8 -> WidthTableRange

-- | The range's starting code point.
[rangeStart] :: WidthTableRange -> Word32

-- | The number of code points in the contiguous range, beginning with the
--   starting code point (<a>rangeStart</a>).
[rangeSize] :: WidthTableRange -> Word32

-- | The terminal width, in columns, of all of the characters corresponding
--   to the code points in this range.
[rangeColumns] :: WidthTableRange -> Word8
instance GHC.Show.Show Graphics.Vty.UnicodeWidthTable.Types.WidthTableRange
instance GHC.Classes.Eq Graphics.Vty.UnicodeWidthTable.Types.WidthTableRange
instance GHC.Show.Show Graphics.Vty.UnicodeWidthTable.Types.UnicodeWidthTable

module Graphics.Vty.UnicodeWidthTable.Query

-- | Construct a unicode character width table by querying the terminal
--   connected to stdout. This works by emitting characters to stdout and
--   then querying the terminal to determine the resulting cursor position
--   in order to measure character widths. Consequently this will generate
--   a lot of output and may take a while, depending on your system
--   performance. This should not be run in a terminal while it is
--   controlled by Vty.
--   
--   The argument specifies the upper bound code point to test when
--   building the table. This allows callers to decide how much of the
--   Unicode code point space to scan when building the table.
--   
--   This does not handle exceptions.
buildUnicodeWidthTable :: Char -> IO UnicodeWidthTable
defaultUnicodeTableUpperBound :: Char

module Graphics.Vty.UnicodeWidthTable.Install

-- | Exception type raised by <a>installUnicodeWidthTable</a>.
data TableInstallException

-- | The width table could not be initialized. Args: failure status,
--   requested table size.
TableInitFailure :: Int -> Int -> TableInstallException

-- | A code point range could not be configured. Args: failure status,
--   offending range.
TableRangeFailure :: Int -> WidthTableRange -> TableInstallException

-- | The table could not be activated. Args: failure status.
TableActivationFailure :: Int -> TableInstallException

-- | Install a custom unicode character width table. Such tables are
--   obtained with <a>buildUnicodeWidthTable</a> and
--   <a>readUnicodeWidthTable</a>.
--   
--   ALERT! This function is probably not what you want to use because it
--   is automatically called by <a>mkVty</a>. You will only ever need to
--   call this function if you want to use functions in <a>Width</a>
--   without controlling the terminal with <a>mkVty</a>.
--   
--   This affects the behavior of the <a>wcwidth</a> function and functions
--   that call it. It does so by changing global state available to the C
--   implementation of <a>wcwidth</a>. To ensure that your program gets
--   consistent results from evaluating calls to <a>wcwidth</a>, the
--   installation of a custom table should be performed before you call
--   <a>wcwidth</a> in your program.
--   
--   This is best done at Vty startup, and if you use <a>mkVty</a>, that
--   function calls this automatically based on the Vty configuration's
--   declared width tables. It is exposed as part of the public API so that
--   applications can call this as needed if they don't want to control the
--   terminal with <tt>mkVty</tt> but do want to make calls to
--   <a>wcwidth</a>.
--   
--   It's also important to note that once a custom table has been
--   installed, it is permanent for the life of the process. No new table
--   can be installed, and the new custom table cannot be removed.
--   
--   If this function fails for any reason -- if the table cannot be
--   installed or is invalid, or if a custom table already exists -- this
--   will raise a <a>TableInstallException</a> exception.
--   
--   This function is thread-safe.
installUnicodeWidthTable :: UnicodeWidthTable -> IO ()

-- | Returns True if and only if a custom table has been allocated and
--   marked as ready for use.
--   
--   This function is thread-safe.
isCustomTableReady :: IO Bool
instance GHC.Show.Show Graphics.Vty.UnicodeWidthTable.Install.TableInstallException
instance GHC.Classes.Eq Graphics.Vty.UnicodeWidthTable.Install.TableInstallException
instance GHC.Exception.Type.Exception Graphics.Vty.UnicodeWidthTable.Install.TableInstallException

module Graphics.Vty.UnicodeWidthTable.IO

-- | Load a binary unicode width table from the specified file.
--   
--   This either returns a successfully parsed table or a table parsing
--   error message. This does not handle I/O exceptions.
readUnicodeWidthTable :: FilePath -> IO (Either String UnicodeWidthTable)

-- | Parse a binary unicode width table.
parseUnicodeWidthTable :: ByteString -> Either String UnicodeWidthTable

-- | Write the unicode width table to the specified path.
--   
--   This does not handle I/O exceptions.
writeUnicodeWidthTable :: FilePath -> UnicodeWidthTable -> IO ()


-- | Vty provides interfaces for both terminal input and terminal output.
--   
--   <ul>
--   <li>Input to the terminal is provided to the Vty application as a
--   sequence of <a>Event</a>s.</li>
--   <li>Output is provided to Vty by the application in the form of a
--   <a>Picture</a>. A <a>Picture</a> is one or more layers of
--   <a>Image</a>s. <a>Image</a> values can be built by the various
--   constructors in <a>Graphics.Vty.Image</a>. Output can be syled using
--   <a>Attr</a> (attribute) values in the <a>Graphics.Vty.Attributes</a>
--   module.</li>
--   </ul>
--   
--   Vty uses threads internally, so programs made with Vty need to be
--   compiled with the threaded runtime using the GHC <tt>-threaded</tt>
--   option.
--   
--   <pre>
--   import <a>Graphics.Vty</a>
--   
--   main = do
--       cfg &lt;- <a>standardIOConfig</a>
--       vty &lt;- <a>mkVty</a> cfg
--       let line0 = <a>string</a> (<a>defAttr</a> ` <a>withForeColor</a> ` <a>green</a>) "first line"
--           line1 = <a>string</a> (<a>defAttr</a> ` <a>withBackColor</a> ` <a>blue</a>) "second line"
--           img = line0 <a>&lt;-&gt;</a> line1
--           pic = <a>picForImage</a> img
--       <a>update</a> vty pic
--       e &lt;- <a>nextEvent</a> vty
--       <a>shutdown</a> vty
--       <a>print</a> ("Last event was: " <a>++</a> <a>show</a> e)
--   </pre>
module Graphics.Vty

-- | A Vty value represents a handle to the Vty library that the
--   application must create in order to use Vty.
--   
--   The use of Vty typically follows this process:
--   
--   <ol>
--   <li>Initialize vty with <a>mkVty</a> (this takes control of the
--   terminal).</li>
--   <li>Use <a>update</a> to display a picture.</li>
--   <li>Use <a>nextEvent</a> to get the next input event.</li>
--   <li>Depending on the event, go to 2 or 5.</li>
--   <li>Shutdown vty and restore the terminal state with <a>shutdown</a>.
--   At this point the <a>Vty</a> handle cannot be used again.</li>
--   </ol>
--   
--   Operations on Vty handles are not thread-safe.
data Vty
Vty :: (Picture -> IO ()) -> IO Event -> IO (Maybe Event) -> Input -> Output -> IO () -> IO () -> IO Bool -> Vty

-- | Outputs the given <a>Picture</a>.
[update] :: Vty -> Picture -> IO ()

-- | Return the next <a>Event</a> or block until one becomes available.
[nextEvent] :: Vty -> IO Event

-- | Non-blocking version of <a>nextEvent</a>.
[nextEventNonblocking] :: Vty -> IO (Maybe Event)

-- | The input interface. See <a>Input</a>.
[inputIface] :: Vty -> Input

-- | The output interface. See <a>Output</a>.
[outputIface] :: Vty -> Output

-- | Refresh the display. If other programs output to the terminal and mess
--   up the display then the application might want to force a refresh
--   using this function.
[refresh] :: Vty -> IO ()

-- | Clean up after vty. A call to this function is necessary to cleanly
--   restore the terminal state before application exit. The above methods
--   will throw an exception if executed after this is executed.
--   Idempotent.
[shutdown] :: Vty -> IO ()
[isShutdown] :: Vty -> IO Bool

-- | Create a Vty handle. At most one handle should be created at a time
--   for a given terminal device.
--   
--   The specified configuration is added to the the configuration loaded
--   by <a>userConfig</a> with the <a>userConfig</a> configuration taking
--   precedence. See <a>Graphics.Vty.Config</a>.
--   
--   For most applications <tt>mkVty defaultConfig</tt> is sufficient.
mkVty :: Config -> IO Vty

-- | Set the terminal window title string.
--   
--   This function emits an Xterm-compatible escape sequence that we
--   anticipate will work for essentially all modern terminal emulators.
--   Ideally we'd use a terminal capability for this, but there does not
--   seem to exist a termcap for setting window titles. If you find that
--   this function does not work for a given terminal emulator, please
--   report the issue.
--   
--   For details, see:
--   
--   <a>https://tldp.org/HOWTO/Xterm-Title-3.html</a>
setWindowTitle :: Vty -> String -> IO ()

-- | Modal terminal features that can be enabled and disabled.
data Mode

-- | Mouse mode (whether the terminal is configured to provide mouse input
--   events)
Mouse :: Mode

-- | Paste mode (whether the terminal is configured to provide events on OS
--   pastes)
BracketedPaste :: Mode

-- | Focus-in/focus-out events (whether the terminal is configured to
--   provide events on focus change)
Focus :: Mode

-- | Hyperlink mode via the <a>withURL</a> attribute modifier (see
--   <a>https://gist.github.com/egmontkob/eb114294efbcd5adb1944c9f3cb5feda)</a>.
--   Note that this may not work gracefully in all terminal emulators so be
--   sure to test this mode with the terminals you intend to support. It is
--   off by default.
Hyperlink :: Mode


-- | The inline module provides a limited interface to changing the style
--   of terminal output. The intention is for this interface to be used
--   inline with other output systems.
--   
--   The changes specified by the InlineM monad are applied to the
--   terminal's display attributes. These display attributes affect the
--   display of all following text output to the terminal file descriptor.
--   
--   For example, in an IO monad the following code will print the text
--   "Not styled. " Followed by the text " Styled! " drawn over a red
--   background and underlined.
--   
--   <pre>
--   putStr "Not styled. "
--   putAttrChange_ $ do
--       backColor red
--       applyStyle underline
--   putStr " Styled! "
--   putAttrChange_ $ defaultAll
--   putStrLn "Not styled."
--   </pre>
--   
--   <a>putAttrChange</a> emits the control codes to the terminal device
--   attached to <a>Handle</a>. This is a duplicate of the <a>stdout</a>
--   handle when the <tt>terminalHandle</tt> was (first) acquired. If
--   <a>stdout</a> has since been changed then <a>putStr</a>,
--   <a>putStrLn</a>, <a>print</a> etc. will output to a different
--   <a>Handle</a> than <a>putAttrChange</a>.
--   
--   Copyright 2009-2010 Corey O'Connor
module Graphics.Vty.Inline
data InlineState
InlineState :: Attr -> Bool -> InlineState
[inlineAttr] :: InlineState -> Attr
[inlineUrlsEnabled] :: InlineState -> Bool
type InlineM v = State InlineState v

-- | Set the background color to the provided <a>Color</a>.
backColor :: Color -> InlineM ()

-- | Set the foreground color to the provided <a>Color</a>.
foreColor :: Color -> InlineM ()

-- | Attempt to change the <a>Style</a> of the following text..
--   
--   If the terminal does not support the style change then no error is
--   produced. The style can still be removed.
applyStyle :: Style -> InlineM ()

-- | Attempt to remove the specified <a>Style</a> from the display of the
--   following text.
--   
--   This will fail if <a>applyStyle</a> for the given style has not been
--   previously called.
removeStyle :: Style -> InlineM ()

-- | Reset the display attributes.
defaultAll :: InlineM ()

-- | Apply the provided display attribute changes to the given terminal
--   output device.
--   
--   This does not flush the terminal.
putAttrChange :: (Applicative m, MonadIO m) => Output -> InlineM () -> m ()

-- | Apply the provided display attributes changes to the terminal output
--   device.
--   
--   This will flush the terminal output.
putAttrChange_ :: (Applicative m, MonadIO m) => InlineM () -> m ()

-- | This will create a Vty instance using <a>mkVty</a> and execute an IO
--   action provided that instance. The created Vty instance will be stored
--   to the unsafe <a>IORef</a> <a>globalVty</a>.
--   
--   This instance will use duplicates of the stdin and stdout Handles.
withVty :: (Vty -> IO b) -> IO b
