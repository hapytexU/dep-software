-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package dep-software
@version 0.1.0.0


-- | This module defines characters to generate images in the user
--   interface. These render wires, boxes, etc.
module Dep.Bricks.Box

-- | A character to render the horizontal border corner of a <i>thick</i>
--   box.
boxh :: Char

-- | A character to render the vertical border corner of a <i>thick</i>
--   box.
boxv :: Char

-- | A character to render the bottom left corner of a <i>thick</i> box.
boxlb :: Char

-- | A character to render the top left corner of a <i>thick</i> box.
boxlt :: Char

-- | A character to render the bottom right corner of a <i>thick</i> box.
boxrb :: Char

-- | A character to render the top right corner of a <i>thick</i> box.
boxrt :: Char

-- | A character to render the horizontal border of a <i>thick</i> box with
--   a wire at at the upper part.
boxhu :: Char

-- | A character to render the horizontal border of a <i>thick</i> box with
--   a wire at at the bottom part.
boxhd :: Char

-- | A character to render the vertical border of a <i>thick</i> box with a
--   wire at at the left part.
boxvl :: Char

-- | A character to render the vertical border of a <i>thick</i> box with a
--   wire at at the right part.
boxvr :: Char

-- | A character to render a <i>wire</i> in a <i>horizontal</i> direction.
lineh :: Char

-- | A character to render a <i>wire</i> in a <i>vertical</i> direction.
linev :: Char

-- | A character to render a negator.
negator :: Char


-- | Specifies how a circuit is rendered. This can be in a
--   <i>horizontal</i> and <i>vertical</i> manner.
module Dep.Bricks.Layout

-- | A data type that specifies whether the circuit is render in a
--   horizontal or vertical manner.
data CircuitLayout

-- | The <i>horizontal</i> orientation.
Horizontal :: CircuitLayout

-- | The <i>vertical</i> orientation.
Vertical :: CircuitLayout
instance GHC.Show.Show Dep.Bricks.Layout.CircuitLayout
instance GHC.Read.Read Dep.Bricks.Layout.CircuitLayout
instance GHC.Classes.Ord Dep.Bricks.Layout.CircuitLayout
instance GHC.Generics.Generic Dep.Bricks.Layout.CircuitLayout
instance GHC.Classes.Eq Dep.Bricks.Layout.CircuitLayout
instance GHC.Enum.Enum Dep.Bricks.Layout.CircuitLayout
instance Data.Data.Data Dep.Bricks.Layout.CircuitLayout
instance GHC.Enum.Bounded Dep.Bricks.Layout.CircuitLayout
instance Data.Hashable.Class.Hashable Dep.Bricks.Layout.CircuitLayout


-- | A module to create images with negations for gates, wires, and other
--   modules.
module Dep.Bricks.Negation

-- | Create an Image that contains a single character that is either the
--   <a>negator</a> or the given <a>Char</a>.
negation :: Char -> Bool -> Attr -> Image

-- | Create an image for a negator on a <i>horizontal</i> wire.
negationH :: Bool -> Attr -> Image

-- | Create an image for a negator on a <i>vertical</i> wire.
negationV :: Bool -> Attr -> Image

-- | Create a list of negators in one of the two directions. The
--   <a>Char</a> specifies what to render in case it is not a negator.
negationList :: (Image -> Image -> Image) -> Char -> [Bool] -> Attr -> Image

-- | Create an <a>Image</a> of negators in the <i>horizontal</i> direction.
--   The wires here are in the <i>vertical</i> direction.
negationHList :: [Bool] -> Attr -> Image

-- | Create an <a>Image</a> of negators in the <i>vertical</i> direction.
--   The wires here are in the <i>horizontal</i> direction.
negationVList :: [Bool] -> Attr -> Image


-- | This module has functions to create gates with an arbitrary number of
--   inputs.
module Dep.Bricks.Gate

-- | Create a gate in the horizontal direction with the given <a>Char</a>
--   that specifies what type of gate it is, and the number of input wires.
gateH :: Char -> Int -> Attr -> Image

-- | Create a gate in the vertical direction with the given <a>Char</a>
--   that specifies what type of gate it is, and the number of input wires.
gateV :: Char -> Int -> Attr -> Image

-- | Create a gate in the given <a>CircuitLayout</a> with the given
--   <a>Char</a> that specifies what type of gate it is, and the number of
--   input wires.
gate :: Char -> CircuitLayout -> Int -> Attr -> Image

-- | A function to create a gate with negators and the input and output.
genericGate :: Char -> CircuitLayout -> [Bool] -> Bool -> Attr -> Image

-- | A helper function to create <i>and</i> gates in a more effective way.
andGate :: CircuitLayout -> Int -> Attr -> Image

-- | A helper function to create <i>horizontal</i> and gates in a more
--   effective way.
andGateH :: Int -> Attr -> Image

-- | A helper function to create a horizontal and gate with <i>two</i>
--   input wires.
andGateH2 :: Attr -> Image

-- | A helper function to create a horizontal and gate with <i>three</i>
--   input wires.
andGateH3 :: Attr -> Image

-- | A helper function to create <i>vertical</i> and gates in a more
--   effective way.
andGateV :: Int -> Attr -> Image

-- | A helper function to create a vertical and gate with <i>two</i> input
--   wires.
andGateV2 :: Attr -> Image

-- | A helper function to create a vertical and gate with <i>three</i>
--   input wires.
andGateV3 :: Attr -> Image

-- | A helper function to create <i>or</i> gates in a more effective way.
orGate :: CircuitLayout -> Int -> Attr -> Image

-- | A helper function to create <i>horizontal</i> or gates in a more
--   effective way.
orGateH :: Int -> Attr -> Image

-- | A helper function to create a horizontal or gate with <i>two</i> input
--   wires.
orGateH2 :: Attr -> Image

-- | A helper function to create a horizontal or gate with <i>three</i>
--   input wires.
orGateH3 :: Attr -> Image

-- | A helper function to create <i>vertical</i> or gates in a more
--   effective way.
orGateV :: Int -> Attr -> Image

-- | A helper function to create a vertical or gate with <i>two</i> input
--   wires.
orGateV2 :: Attr -> Image

-- | A helper function to create a vertical or gate with <i>three</i> input
--   wires.
orGateV3 :: Attr -> Image


-- | This module generates palettes. A <a>Palette</a> is an infinite list
--   of <a>Color</a>s that endlessly repeats itself. This is used to obtain
--   colors to typeset different items on the screen.
module Dep.Bricks.Palette

-- | A palette is an (endless) list of <a>Color</a>s.
type Palette = [Color]

-- | Work with a color palette of the six ISO colors.
isoColorPalette :: Palette

-- | Work with a color palette of the six ISO colors.
brightIsoColorPalette :: Palette

-- | Work with a color palette with 240 colors, but only 238 are selected,
--   since black and white are not considered to be colors for the palette.
color240Palette :: Palette

-- | Swap between the bright mode and the normal mode of the given
--   <a>Color</a>.
swapIsoColorBright :: Color -> Color

-- | Create the brighter color
isoColorToBright :: Color -> Color

-- | Obtain the equivalent color that is <i>not</i> bright.
isoColorFromBright :: Color -> Color


-- | A module that defines three-value logic, for example used in thruth
--   tables, Karnaugh cards, etc.
module Dep.Class.Mergeable

-- | A typeclass that specifies that it is <i>sometimes</i> possible to
--   merge two values together into a new value.
class Mergeable a

-- | Try to merge two values into a new value. The result is wrapped in a
--   <a>Just</a> if it is possible; otherwise <a>Nothing</a> is returned.
merge :: Mergeable a => a -> a -> Maybe a
instance Dep.Class.Mergeable.Mergeable (GHC.Maybe.Maybe a)


-- | This module defines a typeclass <a>Opposite</a> that specifies that
--   each value of a specific type has an opposite value of the same type.
module Dep.Class.Opposite

-- | A typeclass where the values of its members have an opposite element
--   from the same type.
class Opposite a

-- | A function that determines the opposite value.
opposite :: Opposite a => a -> a

-- | A function that determines the opposite value.
opposite :: (Opposite a, Functor f, Opposite b, a ~ f b) => a -> a
instance Dep.Class.Opposite.Opposite GHC.Types.Bool
instance Dep.Class.Opposite.Opposite b => Dep.Class.Opposite.Opposite (a -> b)
instance Dep.Class.Opposite.Opposite a => Dep.Class.Opposite.Opposite [a]
instance Dep.Class.Opposite.Opposite a => Dep.Class.Opposite.Opposite (GHC.Maybe.Maybe a)


-- | A module that has a type class to render items of the types that are
--   members of the typeclass.
module Dep.Class.Renderable

-- | A typeclass that specifies that a certain type can be rendered with a
--   single <a>Char</a>acter.
class CharRenderable a

-- | Render the given item to a <a>Char</a> object.
charRenderItem :: CharRenderable a => a -> Char

-- | A typeclass that specifies that a certain type can be rendered as a
--   DEP <a>Text</a> object.
class Renderable a

-- | Render the given item to a <a>Text</a> object.
renderItem :: Renderable a => a -> Text

-- | Render the given item to a <a>Text</a> object.
renderItem :: (Renderable a, CharRenderable a) => a -> Text
instance Dep.Class.Renderable.Renderable GHC.Types.Bool
instance Dep.Class.Renderable.Renderable GHC.Types.Char
instance Dep.Class.Renderable.CharRenderable a => Dep.Class.Renderable.Renderable (GHC.Maybe.Maybe a)
instance Dep.Class.Renderable.CharRenderable GHC.Types.Bool
instance Dep.Class.Renderable.CharRenderable GHC.Types.Char
instance Dep.Class.Renderable.CharRenderable a => Dep.Class.Renderable.CharRenderable (GHC.Maybe.Maybe a)


-- | The <a>Simplify</a> typeclass exports a function <a>simplify</a> that
--   is used to simplify a value. That function should be
--   <i>idempotent</i>: multiple <a>simplify</a> calls should not have a
--   different result than a single <a>simplify</a> call.
module Dep.Class.Simplify

-- | A typeclass that specifies that the the values of the given type
--   sometimes can be simplfied. The <a>simplify</a> operation is
--   <i>idempotent</i>: calling it multiple times has the same effect as
--   calling it once.
class Simplify a

-- | A function to simplify the given object to a potentially simplier
--   object. This function should be <i>idempotent</i>: calling
--   <a>simplify</a> multiple times has the same effect as calling
--   <a>simplify</a> once.
simplify :: Simplify a => a -> a


-- | A module that defines three-value logic, for example used in thruth
--   tables, Karnaugh cards, etc.
module Dep.Data.ThreeValue

-- | A data type that is used if a value can present three logical values:
--   <i>don't care</i> (or don't know); <i>zero</i>; and <i>one</i>.
data ThreeValue

-- | The value is <i>zero</i> or <i>false</i>.
Zero :: ThreeValue

-- | The value is <i>one</i> or <i>true</i>.
One :: ThreeValue

-- | We do not care or do not know the value.
DontCare :: ThreeValue

-- | Convert the given <a>ThreeValue</a> object to the corresponding value.
--   This acts as a <i>catamorphism</i> for the <a>ThreeValue</a> type.
threeValue :: a -> a -> a -> ThreeValue -> a

-- | Convert the given <a>ThreeValue</a> to a <a>Maybe</a> <a>Bool</a>
--   object. where <a>DontCare</a> is mapped to <a>Nothing</a> and
--   <a>Zero</a> and <a>One</a> to <a>True</a> and <a>False</a> wrapped in
--   a <a>Just</a> accordingly.
toMaybeBool :: ThreeValue -> Maybe Bool

-- | Convert the given <a>ThreeValue</a> to a <a>Char</a> that presents the
--   given value. <a>DontCare</a> is mapped to <tt>-</tt>; <a>Zero</a> to
--   <tt>0</tt>; and <a>One</a> to <tt>1</tt>.
toChar :: ThreeValue -> Char

-- | Convert <a>True</a> and <a>False</a> to <a>Zero</a> and <a>One</a>
--   respectively.
fromBool :: Bool -> ThreeValue

-- | Convert a <a>Maybe</a> <a>Bool</a> to a <a>ThreeValue</a>, where
--   <a>Nothing</a> is mapped to <a>DontCare</a>, and <a>Just</a>
--   <a>True</a> and <a>Just</a> <a>False</a> to <a>One</a> and
--   <a>Zero</a>.
fromMaybeBool :: Maybe Bool -> ThreeValue

-- | A function that maps <a>One</a>s and <a>DontCare</a>s to <a>True</a>s;
--   and <a>Zero</a>s to <a>False</a>.
toUpper :: ThreeValue -> Bool

-- | A function that maps <a>Zero</a>s and <a>DontCare</a>s to
--   <a>False</a>s; and <a>One</a>s to <a>True</a>.
toLower :: ThreeValue -> Bool

-- | A function that determines the opposite value.
opposite :: Opposite a => a -> a

-- | A type alias for a list of <a>ThreeValue</a> objects.
type ThreeValues = [ThreeValue]

-- | A parser that can parse a single <a>ThreeValue</a> from a
--   <a>Char</a>acter. The characters for <a>Zero</a> are <tt>0</tt>,
--   <tt>f</tt> or <tt>F</tt>; the characters for <a>Zero</a> are
--   <tt>1</tt>, <tt>t</tt> or <tt>T</tt>; and the characters for
--   <a>DontCare</a> are <tt>-</tt>, <tt>d</tt> or <tt>D</tt>,
parseThreeValue :: Stream s m Char => ParsecT s u m ThreeValue

-- | A parser that can parse a (possibly empty) list of <a>ThreeValue</a>
--   from a <a>Char</a>acter. The characters for <a>Zero</a> are
--   <tt>0</tt>, <tt>f</tt> or <tt>F</tt>; the characters for <a>Zero</a>
--   are <tt>1</tt>, <tt>t</tt> or <tt>T</tt>; and the characters for
--   <a>DontCare</a> are <tt>-</tt>, <tt>d</tt> or <tt>D</tt>,
parseThreeValues :: Stream s m Char => ParsecT s u m ThreeValues

-- | A parser that can parse a <a>NonEmpty</a> list of <a>ThreeValue</a>
--   from a <a>Char</a>acter. The characters for <a>Zero</a> are
--   <tt>0</tt>, <tt>f</tt> or <tt>F</tt>; the characters for <a>Zero</a>
--   are <tt>1</tt>, <tt>t</tt> or <tt>T</tt>; and the characters for
--   <a>DontCare</a> are <tt>-</tt>, <tt>d</tt> or <tt>D</tt>,
parseThreeValues1 :: Stream s m Char => ParsecT s u m (NonEmpty ThreeValue)
instance GHC.Show.Show Dep.Data.ThreeValue.ThreeValue
instance GHC.Read.Read Dep.Data.ThreeValue.ThreeValue
instance GHC.Classes.Ord Dep.Data.ThreeValue.ThreeValue
instance GHC.Generics.Generic Dep.Data.ThreeValue.ThreeValue
instance GHC.Classes.Eq Dep.Data.ThreeValue.ThreeValue
instance GHC.Enum.Enum Dep.Data.ThreeValue.ThreeValue
instance Data.Data.Data Dep.Data.ThreeValue.ThreeValue
instance GHC.Enum.Bounded Dep.Data.ThreeValue.ThreeValue
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.ThreeValue.ThreeValue
instance Dep.Class.Renderable.CharRenderable Dep.Data.ThreeValue.ThreeValue
instance Data.Default.Class.Default Dep.Data.ThreeValue.ThreeValue
instance Data.Hashable.Class.Hashable Dep.Data.ThreeValue.ThreeValue
instance Language.Haskell.TH.Syntax.Lift Dep.Data.ThreeValue.ThreeValue
instance Dep.Class.Mergeable.Mergeable Dep.Data.ThreeValue.ThreeValue
instance GHC.Base.Monoid Dep.Data.ThreeValue.ThreeValue
instance Control.DeepSeq.NFData Dep.Data.ThreeValue.ThreeValue
instance Dep.Class.Opposite.Opposite Dep.Data.ThreeValue.ThreeValue
instance Dep.Class.Renderable.Renderable Dep.Data.ThreeValue.ThreeValue
instance GHC.Base.Semigroup Dep.Data.ThreeValue.ThreeValue
instance Data.Binary.Class.Binary Dep.Data.ThreeValue.ThreeValue


-- | This module provides utility functions to compress/decompress sums,
--   products, sum-of-products and product-of-sums.
module Dep.Data.LogicItem

-- | A typeclass for objects that can be evaluated to a <a>Bool</a> based
--   on multiple variables. Numbering of the bits starts by <b>one</b>
--   because a <a>CompactSum</a> and <a>CompactProduct</a> start indexes by
--   one, due to the fact that <tt>0</tt> and <tt>-0</tt> are equal.
class EvaluateItem a

-- | Evaluate the given item with a function that derives the value for the
--   given <i>i</i>-th <a>Bool</a>.
evaluateItem :: EvaluateItem a => (Int -> Bool) -> a -> Bool

-- | Determine the outcome of the given <a>EvaluateItem</a> based on the
--   values specified in a <a>Bits</a> object where the <i>i</i>-th
--   <a>Bool</a> is the <i>i-1</i>-th bit of the data.
evaluateWithBits :: (EvaluateItem a, Bits b) => b -> a -> Bool

-- | Check if the given object is trivially <a>True</a> (<a>One</a>);
--   <a>False</a> (<a>Zero</a>), or a non-trivial function
--   (<a>DontCare</a>).
isTrivial :: EvaluateItem a => a -> ThreeValue

-- | Determine the largest index of the variables for which the
--   <a>EvaluateItem</a> is sensitive for.
numberOfVariables :: EvaluateItem a => a -> Int

-- | A class that specifies that a given logic item can be made more
--   compact, or from a compact form to its original form. The two
--   functions are not per se fully each others inverse.
class ToCompact a b | a -> b

-- | Convert the given item to a more compact representation.
toCompact :: ToCompact a b => a -> b

-- | Convert the given item from a compact representation to its normal
--   presentation.
fromCompact :: ToCompact a b => b -> a

-- | Read a list o <a>ThreeValue</a>s from a binary stream where each byte
--   represents (up to) four <a>ThreeValue</a>s.
getThreeList :: Get ThreeValues

-- | Convert the given list of <a>ThreeValue</a>s to a writer for a binary
--   stream that encodes four <a>ThreeValue</a>s on one byte.
putThreeList :: ThreeValues -> Put

-- | Convert the given number to a <a>Text</a> object containing the "root"
--   variable name and the index as subscript.
subscriptVariable :: Char -> Int -> Text

-- | Convert the given number to a <a>Text</a> object containing the "root"
--   variable name and the index as subscript.
subscriptNegatedVariable :: Char -> Int -> Text

-- | Convert the given number to a <a>Text</a> objet that contains the
--   "root" variable, name, the index, and based on a given <a>Bool</a> can
--   include a quote mark if the variable should be <a>False</a>.
subscriptConditionVariable :: Char -> Int -> Bool -> Text

-- | An alias for <a>ThreeValues</a>: an item (<a>Product</a> or
--   <a>Sum</a>) is a sequence of <a>ThreeValue</a>s.
type Item' = ThreeValues
instance Dep.Data.LogicItem.ToCompact [Dep.Data.ThreeValue.ThreeValue] [GHC.Types.Int]


-- | This module defines utility functions that are used elsewhere in the
--   software package.
module Dep.Utils

-- | Convert the given <a>Foldable</a> object to a list where one can
--   specify a tail list.
toList' :: Foldable f => f a -> [a] -> [a]

-- | Perform a <a>zipWith</a>, but when one of the lists is exhausted the
--   remaining elements of the other list are returned.
zipWithLast :: (a -> a -> a) -> [a] -> [a] -> [a]

-- | A function that create an expression by calling the function with the
--   given name and a <a>Foldable</a> of parameters that are applied.
applyExp :: Foldable f => Name -> f (Q Exp) -> Q Exp

-- | A function that create an expression by calling the function with the
--   given name and a <a>Foldable</a> of items that are an instance of
--   <a>Lift</a>. The <i>lifted</i> version of these items will be used to
--   construct the expression.
applyExp' :: (Lift a, Foldable f) => Name -> f a -> Q Exp

-- | Using the merge function if the two given <a>Maybe</a>s use the
--   <a>Just</a> data constructor. If one of the two is <a>Nothing</a>,
--   then the item with the <a>Just</a> compiler is used. If the two are
--   both <a>Nothing</a>, <a>Nothing</a> is returned.
unionMaybeWith :: (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a

-- | Divide the numerator by the denominator and round up.
udiv :: Integral i => i -> i -> i

-- | A <a>Raster</a> is a list of lists of items. This is for example used
--   to render an image with <i>Bricks</i> where there are multiple layers.
type Raster a = [[a]]

-- | Convert the given <a>Raster</a>s to a <a>Raster</a> of 2-tuples where
--   the first item is a given "label" or "attribute".
toRaster :: a -> Raster b -> Raster (a, b)

-- | Convert a list of labeled <a>Raster</a>s to a single <a>Raster</a>
--   where the predicate determines from which value we take the item.
flatRaster :: (b -> Bool) -> [(a, Raster b)] -> Raster (a, b)

-- | Convert the given <a>Raster</a>s to a raster where the given predicate
--   decides if we retain the upper or lower layer.
flatRaster' :: (a -> Bool) -> [Raster a] -> Raster a

-- | An alias for an <i>operator</i>: a function that takes two items of
--   the same type, and produces an item. In case the function is
--   <i>associative</i>, this can be used for a <a>Semigroup</a>.
type Operator a = (a, a) -> a


-- | This module defines a typeclass <a>Walkable</a> that specifies that
--   one can walk through a deterministic data structure for a given type
--   of "steps".
module Dep.Class.Walkable

-- | A typeclass that specifies that we can walk through a datastructure
--   with steps.
class Walkable f step | f -> step

-- | Take one step with the given step parameter, and return an object with
--   the same type.
step :: Walkable f step => f a -> step -> f a

-- | Obtain the values of the item after making a step.
stepValues' :: (Walkable f step, Foldable f) => f a -> step -> [a] -> [a]

-- | Obtain the values of the item after making a step.
stepValues :: (Walkable f step, Foldable f) => f a -> step -> [a]

-- | Apply the same step for all the items in the given collection
--   (functor) of items.
allStep :: (Walkable f step, Functor g) => g (f a) -> step -> g (f a)

-- | Obtain the values of the items after making the same step for all
--   items.
allStepValues' :: (Walkable f step, Foldable f, Foldable g) => g (f a) -> step -> [a] -> [a]

-- | Obtain the values of the items after making the same step for all
--   items.
allStepValues :: (Walkable f step, Foldable f, Foldable g) => g (f a) -> step -> [a]

-- | Take a sequence of steps with the given list of steps.
walk :: (Walkable f step, Foldable g) => f a -> g step -> f a

-- | Take a sequence of steps with the given list of steps and return the
--   values out of the target state.
walkValues' :: (Walkable f step, Foldable f, Foldable g) => f a -> g step -> [a] -> [a]

-- | Obtain all the values the <a>Foldable</a> f spans after performing the
--   same (<a>Foldable</a>) of steps on all the given intial states.
allWalkValues :: (Walkable f step, Foldable f, Foldable g, Functor g, Foldable h) => g (f a) -> h step -> [a]
allWalk :: (Walkable f step, Functor g, Foldable h) => g (f a) -> h step -> g (f a)


-- | This module defines a typeclass <a>NonDeterministicWalkable</a> that
--   specifies that one can walk through a non-deterministic data structure
--   where a certain step can result in zero, one, or more new states.
module Dep.Class.NonDeterministicWalkable

-- | A typeclass that specifies that we can walk through the given
--   datastructure where steps can be non-deterministic and thus result in
--   <i>multiple</i> possible states.
class NonDeterministicWalkable f step | f -> step

-- | Take a non-deterministic step that can result in multiple outcomes.
--   One can specify a tail to make concatenating of lists more efficient.
nstep' :: NonDeterministicWalkable f step => f a -> step -> [f a] -> [f a]

-- | Take a non-deterministic step that can result in multiple outcomes.
nstep :: NonDeterministicWalkable f step => f a -> step -> [f a]

-- | Obtain the values stored in the <a>Foldable</a> after making a
--   non-deterministic step (which can result in zero, one or more new
--   states).
nstepValues' :: (NonDeterministicWalkable f step, Foldable f) => f a -> step -> [a] -> [a]

-- | Obtain the values stored in the <a>Foldable</a> after making a
--   non-deterministic step (which can result in zero, one or more new
--   states).
nstepValues :: (NonDeterministicWalkable f step, Foldable f) => f a -> step -> [a]

-- | Take the same non-deterministic step for all initial states. This can
--   result in multiple outcomes. One can specify a tail to make
--   concatenating of lists more efficient.
allNstep' :: (NonDeterministicWalkable f step, Foldable g) => g (f a) -> step -> [f a] -> [f a]

-- | Take the same non-deterministic step for all initial states. This can
--   result in multiple outcomes.
allNstep :: (NonDeterministicWalkable f step, Foldable g) => g (f a) -> step -> [f a]

-- | Make a non-deterministic step for each state in the collection, and
--   collect the data of the <a>Foldable</a>s after making.
allNstepValues :: (NonDeterministicWalkable f step, Foldable f) => [f a] -> step -> [a]
nwalk :: (NonDeterministicWalkable f step, Foldable g) => f a -> g step -> [f a]
nwalkValues :: (NonDeterministicWalkable f step, Foldable f, Foldable g) => f a -> g step -> [a]

-- | Make a non-deterministic walk with a collection of states that can
--   result in multiple paths.
allNwalk :: (NonDeterministicWalkable f step, Foldable g) => [f a] -> g step -> [f a]

-- | Make a non-deterministic walk with a collection of states that can
--   result in multiple paths.
allNwalkValues :: (NonDeterministicWalkable f step, Foldable f, Foldable g) => [f a] -> g step -> [a]


-- | This modules defines a <i>three</i>, a tree-like data structure with a
--   leaf, a node, and a link where both subtrees are the same. This is
--   used to make more compact and efficient representations of a boolean
--   function.
module Dep.Data.Three

-- | A data structure used to specify a mapping from a list of booleans to
--   a value in a more compact way. This datastructure can effectively be
--   used to define a sum of products or a product of sums.
data Three a

-- | A <i>leaf</i> that contains a single value.
Leaf :: a -> Three a

-- | A <i>link</i> where it means that this variable does not matter but
--   the next one(s) will.
Link :: Three a -> Three a

-- | A <i>split</i> where this variable determines the outcome.
Split :: Three a -> Three a -> Three a

-- | A type of a list (non-deterministic) steps in a <a>Three</a>
--   structure.
type ThreePath = [ThreeStep]

-- | A type alias for (non-deterministic) steps in a <a>Three</a>
--   structure.
type ThreeStep = ThreeValue

-- | A catamorphism on the <a>Three</a> object. Here one can provide
--   functions to use for the <a>Leaf</a>, the <a>Link</a> and the
--   <a>Split</a> to catamorph a <a>Three</a> object to another object.
three :: (a -> b) -> (b -> b) -> (b -> b -> b) -> Three a -> b

-- | Determine the maximum depth of the <a>Three</a> tree.
depth :: Three a -> Int

-- | Obtain the leftmost item of the <a>Three</a>.
leftmost :: Three a -> a

-- | Obtain the rightmost item of the <a>Three</a>.
rightmost :: Three a -> a

-- | Flip the most basic level such that <a>True</a> now maps on
--   <a>False</a> and vice versa. This is for example used to render
--   <i>Karnaugh cards</i>.
flipThree :: Three a -> Three a

-- | Flip all the nodes in the <a>Three</a> such that the <a>False</a>
--   subtree is now a <a>True</a> subtree, and the <a>True</a> subtree is
--   now the <a>False</a> subtree.
flipAllThree :: Three a -> Three a

-- | Take a non-deterministic step that can result in multiple outcomes.
nstep :: NonDeterministicWalkable f step => f a -> step -> [f a]

-- | Construct a <a>Three</a> that will apply the given function for the
--   items that satisfy the given <i>path</i> of three-valued objects.
apply :: (a -> a) -> ThreePath -> Three (a -> a)

-- | Apply the given function to the elements in the given <a>Three</a>
--   that satisfy the given path.
applyTo :: (a -> a) -> ThreePath -> Three a -> Three a

-- | Convert the given items that match the given <a>ThreePath</a> to the
--   <a>Leaf</a> with a given element.
wipe :: a -> ThreePath -> Three a -> Three a

-- | Wipe with the given value all the given <a>ThreePath</a>s.
wipeAll :: a -> Three a -> [ThreePath] -> Three a

-- | Obtain the children that satisfy a given <a>ThreePath</a>.
children :: ThreePath -> Three a -> [a]

-- | Obtain the children that satisfy the given <a>ThreePath</a>.
children' :: ThreePath -> Three a -> [a] -> [a]

-- | Convert the given <a>Three</a> to a list of 2-tuples with as first
--   item the "address" in <b>reverse</b>, and as second item the value
--   associated with this.
toTraces :: Three a -> [(ThreeValues, a)]

-- | Convert the given <a>Three</a> to a list of 2-tuples with as first
--   item the "address" in <b>reverse</b>, and as second item the value
--   associated with this.
toTraces' :: Three a -> [(ThreeValues, a)] -> [(ThreeValues, a)]

-- | Convert the given <a>Three</a> to a list of 2-tuples with as first
--   item the "address" in <b>reverse</b>, and as second item the value
--   associated with this.
toTraces'' :: Three a -> ThreeValues -> [(ThreeValues, a)] -> [(ThreeValues, a)]
instance Data.Traversable.Traversable Dep.Data.Three.Three
instance GHC.Show.Show a => GHC.Show.Show (Dep.Data.Three.Three a)
instance GHC.Read.Read a => GHC.Read.Read (Dep.Data.Three.Three a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Dep.Data.Three.Three a)
instance GHC.Generics.Generic1 Dep.Data.Three.Three
instance GHC.Generics.Generic (Dep.Data.Three.Three a)
instance GHC.Base.Functor Dep.Data.Three.Three
instance Data.Foldable.Foldable Dep.Data.Three.Three
instance GHC.Classes.Eq a => GHC.Classes.Eq (Dep.Data.Three.Three a)
instance Data.Data.Data a => Data.Data.Data (Dep.Data.Three.Three a)
instance Data.Functor.Classes.Eq1 Dep.Data.Three.Three
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Dep.Data.Three.Three a)
instance Data.Hashable.Class.Hashable1 Dep.Data.Three.Three
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Dep.Data.Three.Three a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Dep.Data.Three.Three a)
instance Control.DeepSeq.NFData1 Dep.Data.Three.Three
instance Data.Functor.Classes.Ord1 Dep.Data.Three.Three
instance GHC.Classes.Eq a => Dep.Class.Simplify.Simplify (Dep.Data.Three.Three a)
instance Dep.Class.Walkable.Walkable Dep.Data.Three.Three GHC.Types.Bool
instance Dep.Class.NonDeterministicWalkable.NonDeterministicWalkable Dep.Data.Three.Three Dep.Data.ThreeValue.ThreeValue
instance Dep.Class.Opposite.Opposite a => Dep.Class.Opposite.Opposite (Dep.Data.Three.Three a)
instance Data.Default.Class.Default a => Data.Default.Class.Default (Dep.Data.Three.Three a)
instance GHC.Base.Applicative Dep.Data.Three.Three
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Dep.Data.Three.Three a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Dep.Data.Three.Three a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Dep.Data.Three.Three
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Dep.Data.Three.Three a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Dep.Data.Three.Three a)


-- | This module provides utility functions to compress/decompress sums,
--   and render these <a>Product'</a>s to a unicode string.
module Dep.Data.Sum

-- | A data type that can be used to specify a sum. By using a newtype, we
--   can add special instance to the <a>Sum</a>.
newtype Sum
Sum :: Sum' -> Sum

-- | A type alias for a sum that is a <a>ThreePath</a>.
type Sum' = ThreePath

-- | A data type that can be used to specify a <a>CompactSum</a>. By using
--   a new type, this means that we can define other instances than these
--   for a list of <a>Int</a>.
newtype CompactSum
CompactSum :: CompactSum' -> CompactSum

-- | A more compact representation of a sum where the indexes that have
--   <a>Zero</a> or <a>One</a> are listed by the <i>positive</i> or
--   <i>negative</i> index respectively.
type CompactSum' = [Int]

-- | A data type that is used to specify a product of sums. This type can
--   be used to specify new instance other than these of a list of lists of
--   <a>Int</a>s.
newtype ProductOfSums
ProductOfSums :: [Sum] -> ProductOfSums

-- | A type synonym to present a product of sums where each item of the
--   list is a <a>Sum'</a>.
type ProductOfSums' = [Sum']

-- | Convert the given product of sums to a <a>Text</a> object that
--   presents the <a>ProductOfSums'</a> as a <a>Text</a> object with
--   variables as subscript.
--   
--   <pre>
--   &gt;&gt;&gt; showProductOfSums 'x' [[One, One], [DontCare, Zero, One]]
--   "(x₀x₁)(x₁'x₂)"
--   </pre>
showProductOfSums :: Char -> ProductOfSums' -> Text

-- | Print a given sum as a sequence of variables that can be negated. for
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; showSum 'x' [One, DontCare, Zero, One]
--   "x₀ + x₂' + x₃"
--   </pre>
showSum :: Char -> Sum' -> Text

-- | Print a given sum as a sequence of variables that can be negated. for
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; showSum' 'x' mempty [One, DontCare, Zero, One]
--   "x₀ + x₂' + x₃"
--   </pre>
showSum' :: Char -> Text -> Sum' -> Text
instance GHC.Show.Show Dep.Data.Sum.Sum
instance GHC.Read.Read Dep.Data.Sum.Sum
instance GHC.Classes.Ord Dep.Data.Sum.Sum
instance GHC.Generics.Generic Dep.Data.Sum.Sum
instance GHC.Classes.Eq Dep.Data.Sum.Sum
instance Data.Data.Data Dep.Data.Sum.Sum
instance GHC.Show.Show Dep.Data.Sum.CompactSum
instance GHC.Read.Read Dep.Data.Sum.CompactSum
instance GHC.Classes.Ord Dep.Data.Sum.CompactSum
instance GHC.Generics.Generic Dep.Data.Sum.CompactSum
instance GHC.Classes.Eq Dep.Data.Sum.CompactSum
instance Data.Data.Data Dep.Data.Sum.CompactSum
instance GHC.Show.Show Dep.Data.Sum.ProductOfSums
instance GHC.Read.Read Dep.Data.Sum.ProductOfSums
instance GHC.Classes.Ord Dep.Data.Sum.ProductOfSums
instance GHC.Generics.Generic Dep.Data.Sum.ProductOfSums
instance GHC.Classes.Eq Dep.Data.Sum.ProductOfSums
instance Data.Data.Data Dep.Data.Sum.ProductOfSums
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Sum.ProductOfSums
instance Data.Binary.Class.Binary Dep.Data.Sum.ProductOfSums
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Sum.ProductOfSums
instance Data.Hashable.Class.Hashable Dep.Data.Sum.ProductOfSums
instance Control.DeepSeq.NFData Dep.Data.Sum.ProductOfSums
instance GHC.Base.Semigroup Dep.Data.Sum.ProductOfSums
instance GHC.Base.Monoid Dep.Data.Sum.ProductOfSums
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Sum.CompactSum
instance Data.Binary.Class.Binary Dep.Data.Sum.CompactSum
instance Data.Hashable.Class.Hashable Dep.Data.Sum.CompactSum
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Sum.CompactSum
instance Control.DeepSeq.NFData Dep.Data.Sum.CompactSum
instance Dep.Data.LogicItem.ToCompact Dep.Data.Sum.Sum Dep.Data.Sum.CompactSum
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Sum.Sum
instance Data.Binary.Class.Binary Dep.Data.Sum.Sum
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Sum.Sum
instance Data.Hashable.Class.Hashable Dep.Data.Sum.Sum
instance Control.DeepSeq.NFData Dep.Data.Sum.Sum


-- | This module provides utility functions to compress/decompress
--   products, and render these <a>Product'</a>s to a unicode string.
module Dep.Data.Product

-- | A data type that can be used to specify a product. By using a newtype,
--   we can add special instance to the <a>Product</a>.
newtype Product
Product :: Product' -> Product

-- | A type alias for a product that is a <a>ThreePath</a>.
type Product' = ThreePath

-- | A data type that can be used to specify a <a>CompactProduct</a>. By
--   using a new type, this means that we can define other instances than
--   these for a list of <a>Int</a>.
newtype CompactProduct
CompactProduct :: CompactProduct' -> CompactProduct

-- | A more compact representation of a product where the indexes that have
--   <a>Zero</a> or <a>One</a> are listed by the <i>positive</i> or
--   <i>negative</i> index respectively.
type CompactProduct' = [Int]

-- | A data type that is used to specify a sum of products. This type can
--   be used to specify new instance other than these of a list of lists of
--   <a>Int</a>s.
newtype SumOfProducts
SumOfProducts :: [Product] -> SumOfProducts

-- | A type synonym to present a sum of products where each item of the
--   list is a <a>Product'</a>.
type SumOfProducts' = [Product']

-- | Convert the given sum of products to a <a>Text</a> object that
--   presents the <a>SumOfProducts'</a> as a <a>Text</a> object with
--   variables as subscript.
--   
--   <pre>
--   &gt;&gt;&gt; showSumOfProducts 'x' [[One, One], [DontCare, Zero, One]]
--   "x₀x₁ + x₁'x₂"
--   </pre>
showSumOfProducts :: Char -> SumOfProducts' -> Text

-- | Print a given product as a sequence of variables that can be negated.
--   for example:
--   
--   <pre>
--   &gt;&gt;&gt; showProduct 'x' [One, DontCare, Zero, One]
--   "x₀x₂'x₃"
--   </pre>
showProduct :: Char -> Product' -> Text

-- | Print a given product as a sequence of variables that can be negated.
--   for example:
--   
--   <pre>
--   &gt;&gt;&gt; showProduct' 'x' mempty [One, DontCare, Zero, One]
--   "x₀x₂'x₃"
--   </pre>
showProduct' :: Char -> Text -> Product' -> Text

-- | Convert the given number to a <a>Text</a> object containing the "root"
--   variable name and the index as subscript.
subscriptVariable :: Char -> Int -> Text
instance GHC.Show.Show Dep.Data.Product.Product
instance GHC.Read.Read Dep.Data.Product.Product
instance GHC.Classes.Ord Dep.Data.Product.Product
instance GHC.Generics.Generic Dep.Data.Product.Product
instance GHC.Classes.Eq Dep.Data.Product.Product
instance Data.Data.Data Dep.Data.Product.Product
instance GHC.Show.Show Dep.Data.Product.CompactProduct
instance GHC.Read.Read Dep.Data.Product.CompactProduct
instance GHC.Classes.Ord Dep.Data.Product.CompactProduct
instance GHC.Generics.Generic Dep.Data.Product.CompactProduct
instance GHC.Classes.Eq Dep.Data.Product.CompactProduct
instance Data.Data.Data Dep.Data.Product.CompactProduct
instance GHC.Show.Show Dep.Data.Product.SumOfProducts
instance GHC.Read.Read Dep.Data.Product.SumOfProducts
instance GHC.Classes.Ord Dep.Data.Product.SumOfProducts
instance GHC.Generics.Generic Dep.Data.Product.SumOfProducts
instance GHC.Classes.Eq Dep.Data.Product.SumOfProducts
instance Data.Data.Data Dep.Data.Product.SumOfProducts
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Product.SumOfProducts
instance Data.Binary.Class.Binary Dep.Data.Product.SumOfProducts
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Product.SumOfProducts
instance Data.Hashable.Class.Hashable Dep.Data.Product.SumOfProducts
instance Control.DeepSeq.NFData Dep.Data.Product.SumOfProducts
instance GHC.Base.Semigroup Dep.Data.Product.SumOfProducts
instance GHC.Base.Monoid Dep.Data.Product.SumOfProducts
instance Dep.Data.LogicItem.ToCompact Dep.Data.Product.Product Dep.Data.Product.CompactProduct
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Product.CompactProduct
instance Data.Binary.Class.Binary Dep.Data.Product.CompactProduct
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Product.CompactProduct
instance Data.Hashable.Class.Hashable Dep.Data.Product.CompactProduct
instance Control.DeepSeq.NFData Dep.Data.Product.CompactProduct
instance Test.QuickCheck.Arbitrary.Arbitrary Dep.Data.Product.Product
instance Data.Binary.Class.Binary Dep.Data.Product.Product
instance Dep.Data.LogicItem.EvaluateItem Dep.Data.Product.Product
instance Data.Hashable.Class.Hashable Dep.Data.Product.Product
instance Control.DeepSeq.NFData Dep.Data.Product.Product


-- | This module defines functions to generate a <i>sum-of-products</i> or
--   a <i>product-of-sums</i> with the given function specified by a
--   <a>Three</a>.
module Dep.Algorithm.Synthesis

-- | Create a <a>SumOfProducts</a> object based on the given <a>Three</a>
--   of <a>ThreeValue</a>s. This function acts as an alias for the
--   <a>synthesisSOP</a> function.
synthesis :: Three ThreeValue -> SumOfProducts

-- | Create a sum-of-products for the given function of <a>ThreeValue</a>.
--   This function is an alias of the <a>synthesisSOP</a> function.
synthesis' :: Three ThreeValue -> SumOfProducts'

-- | Create a <a>SumOfProducts</a> object based on the given <a>Three</a>
--   of <a>ThreeValue</a>s.
synthesisSOP :: Three ThreeValue -> SumOfProducts

-- | Create a sum-of-products for the given function of <a>ThreeValue</a>.
synthesisSOP' :: Three ThreeValue -> SumOfProducts'

-- | Create a <a>ProductOfSums</a> object based on the given <a>Three</a>
--   of <a>ThreeValue</a>s.
synthesisPOS :: Three ThreeValue -> ProductOfSums

-- | Create a sum-of-products for the given function of <a>ThreeValue</a>.
synthesisPOS' :: Three ThreeValue -> ProductOfSums'

-- | A 2-tuple where the first item is the "weight" of the product, and the
--   second one the corresponding <a>Product'</a>.
type WeightedProduct = (Int, Product')

-- | A 2-tuple where the first item is the "weight" of the sum, and the
--   second one the corresponding <a>Sum'</a>.
type WeightedSum = (Int, Sum')

-- | Create a <i>simplified</i> <a>Three</a> where the <a>DontCare</a> and
--   <a>One</a> map to <a>True</a>; and <a>Zero</a> maps to <a>False</a>.
upperbound :: Three ThreeValue -> Three Bool

-- | Create a <i>simplified</i> <a>Three</a> where the <a>DontCare</a> and
--   <a>Zero</a> map to <a>False</a>; and <a>One</a> maps to <a>True</a>.
lowerbound :: Three ThreeValue -> Three Bool

-- | Obtain a <a>Product'</a> together with the number of inputs for the
--   AND gate if the <a>Three</a> contains at least one <a>One</a>.
extractProduct :: Int -> Three Bool -> Three ThreeValue -> Maybe WeightedProduct

-- | Obtain a <a>Sum'</a> together with the number of inputs for the OR
--   gates if the <a>Three</a> contains at least one <a>Zero</a>.
extractSum :: Int -> Three Bool -> Three ThreeValue -> Maybe WeightedSum

-- | Convert the items that are accessed by the <a>Product'</a> to a
--   <a>DontCare</a>, and simplify the <a>Three</a>. After wiping out
--   values, the <a>Three</a> is simplified.
wipeout :: Product' -> Three ThreeValue -> Three ThreeValue

-- | Convert the items that are accessed by the <a>Product'</a> to a
--   <a>DontCare</a>, and simplify the <a>Three</a>.
wipeout' :: Product' -> Three ThreeValue -> Three ThreeValue


-- | A module that is used to render lines, arrows, rasters, etc.
module Dep.Bricks.Utils

-- | Convert a given list of strings to an <a>Image</a> where all the
--   images have the same attribute.
fromRaster :: Attr -> Raster -> Image

-- | Render a <i>horizontal</i> line by cycling through the given
--   <a>Text</a> and apply the given <a>Attr</a>ibute to the result.
hline :: Text -> Attr -> Int -> Image

-- | A function equivalent to <a>hline</a>, but with a <a>String</a> to
--   specify the <a>Char</a>acters instead of a <a>Text</a> object.
hline' :: String -> Attr -> Int -> Image

-- | Render a <i>vertical</i> line by cycling through the given <a>Text</a>
--   and apply the given <a>Attr</a>ibute to the result.
vline :: Text -> Attr -> Int -> Image

-- | A function equivalent to <a>vline</a>, but with a <a>String</a> to
--   specify the <a>Char</a>acters instead of a <a>Text</a> object.
vline' :: String -> Attr -> Int -> Image

-- | Render a <i>horizontal</i> arrow with the given number of characters
--   between the arrow heads. The <a>Text</a> in the middle is
--   "<i>cycled</i>".
harrow :: Char -> Text -> Char -> Attr -> Int -> Image

-- | A function equivalent to <a>harrow</a>, but where we use a
--   <a>String</a> to specify the <a>Char</a>acters in the middle.
harrow' :: Char -> String -> Char -> Attr -> Int -> Image

-- | Render a <i>vertical</i> arrow with the given number of characters
--   between the arrow heads. The <a>Text</a> in the middle is
--   "<i>cycled</i>".
varrow :: Char -> Text -> Char -> Attr -> Int -> Image

-- | A function equivalent to <a>varrow</a>, but where we use a
--   <a>String</a> to specify the <a>Char</a>acters in the middle.
varrow' :: Char -> String -> Char -> Attr -> Int -> Image

-- | A Row is a simple <a>String</a>, typically a row in an <a>Raster</a>
--   (and later an <a>Image</a>).
type Row = String

-- | A list of lists of <a>Char</a>acters is a <a>Raster</a>, typically
--   this is used to convert this to an <a>Image</a>.
type Raster = [Row]

-- | Wrap the given <a>Image</a> in a raster structure with thick borders
--   and with small lines for the raster image in the middle.
inRaster :: Attr -> Image -> Image

-- | Wrap the given list of <a>String</a>s in a raster structure with thick
--   borders and with small lines for the raster image in the middle.
inRaster' :: Raster -> Raster


-- | This module exports the <a>mergeLayers</a> function that combine
--   multiple <a>Layer</a>s in a single layer. This is used if writing
--   several layers is easier than writing a single image.
module Dep.Bricks.Layered

-- | A raster is a list of lists of characters.
type Layer a = [[a]]

-- | Convert a list of lists of 2-tuples that contain an <a>Attr</a>ibutes
--   and a <a>Char</a> to an <a>Image</a>.
createImage :: [[(Attr, Char)]] -> Image

-- | Merge the given <a>Layer</a>s with the corresponding <a>Attr</a>ibutes
--   to a single <a>Image</a>.
mergeLayers :: (Char -> Bool) -> [(Attr, Layer Char)] -> Image


-- | A module to render, update, and interact with Karnaugh cards.
module Dep.Bricks.Karnaugh

-- | Render the given <a>Three</a> as a <i>Karnaugh</i> card, that can also
--   visualize the <i>sum-of-product</i>.
renderKarnaugh :: CharRenderable a => Three a -> SumOfProducts -> [String] -> Attr -> Image

-- | Render the given <a>Three</a> as a <i>Karnaugh</i> card, that can also
--   visualize the <i>sum-of-product</i>.
renderKarnaugh' :: Three ThreeValue -> [String] -> Attr -> Image


-- | A module to render circuits in an effective manner.
module Dep.Bricks.Circuit

-- | A widget that is used to render electronics circuitry.
circuit :: Widget ()


-- | This module exports functions to help determine how different two
--   sequences are. This is used to guess the name of the command if the
--   command given by the user does not map on an action.
module Dep.Algorithm.Levenshtein

-- | A data type that is used to list how to edit a sequence to form
--   another sequence.
data Edit a

-- | We add the given element to the sequence.
Add :: a -> Edit a

-- | We remove the given element to the sequence.
Rem :: a -> Edit a

-- | We copy an element from the sequence, this basically act as a
--   <i>no-op</i>.
Copy :: a -> Edit a

-- | We modify the given first item into the second item, this thus denotes
--   a replacement.
Swap :: a -> a -> Edit a

-- | Determine the standard edit score for the <i>Levenshtein distance</i>.
editScore :: Edit a -> Int

-- | Determine the score for the <i>Levenshtein distance</i> for a
--   <a>Foldable</a> of <a>Edit</a>s.
editScore' :: Foldable f => f (Edit a) -> Int

-- | Obtain the <i>Levenshtein distance</i> from one sequence ot another,
--   given we each time add one point for an addition, deletion and
--   substitution.
levenshtein :: Eq a => [a] -> [a] -> (Int, [Edit a])

-- | Obtain the <i>Levenshtein distance</i> from one sequence ot another,
--   given we each time add one point for an addition, deletion and
--   substitution. The equality relation is given, for example to perform
--   case-insensitive matching.
levenshtein' :: (a -> a -> Bool) -> [a] -> [a] -> (Int, [Edit a])

-- | Obtain the <i>Levenshtein distance</i> where the list of edits is in
--   <i>reverse</i> order. This because this is more efficient and is thus
--   useful if the order of the <a>Edit</a>s does not matter much.
reversedLevenshtein :: Eq a => [a] -> [a] -> (Int, [Edit a])

-- | Obtain the <i>Levenshtein distance</i> where the list of edits is in
--   <i>reverse</i> order. This because this is more efficient and is thus
--   useful if the order of the <a>Edit</a>s does not matter much. The
--   equivalence relation is given through a parameter, and thus can for
--   example allow case-insensitive matching.
reversedLevenshtein' :: (a -> a -> Bool) -> [a] -> [a] -> (Int, [Edit a])

-- | A function to determine the <i>Levenshtein distance</i> by specifying
--   the cost functions of adding, removing and editing characters. The
--   2-tuple returns the distance as first item of the 2-tuple, and the
--   list of <a>Edit</a>s in reverse order as second item.
genericReversedLevenshtein :: Eq a => (a -> Int) -> (a -> Int) -> (a -> a -> Int) -> [a] -> [a] -> (Int, [Edit a])

-- | A function to determine the <i>Levenshtein distance</i> by specifying
--   the cost functions of adding, removing and editing characters. The
--   2-tuple returns the distance as first item of the 2-tuple, and the
--   list of <a>Edit</a>s in reverse order as second item.
genericReversedLevenshtein' :: (a -> a -> Bool) -> (a -> Int) -> (a -> Int) -> (a -> a -> Int) -> [a] -> [a] -> (Int, [Edit a])
instance Data.Traversable.Traversable Dep.Algorithm.Levenshtein.Edit
instance GHC.Show.Show a => GHC.Show.Show (Dep.Algorithm.Levenshtein.Edit a)
instance GHC.Read.Read a => GHC.Read.Read (Dep.Algorithm.Levenshtein.Edit a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Dep.Algorithm.Levenshtein.Edit a)
instance GHC.Generics.Generic1 Dep.Algorithm.Levenshtein.Edit
instance GHC.Generics.Generic (Dep.Algorithm.Levenshtein.Edit a)
instance GHC.Base.Functor Dep.Algorithm.Levenshtein.Edit
instance Data.Foldable.Foldable Dep.Algorithm.Levenshtein.Edit
instance GHC.Classes.Eq a => GHC.Classes.Eq (Dep.Algorithm.Levenshtein.Edit a)
instance Data.Data.Data a => Data.Data.Data (Dep.Algorithm.Levenshtein.Edit a)
instance Test.QuickCheck.Arbitrary.Arbitrary1 Dep.Algorithm.Levenshtein.Edit
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Dep.Algorithm.Levenshtein.Edit a)
instance Data.Binary.Class.Binary a => Data.Binary.Class.Binary (Dep.Algorithm.Levenshtein.Edit a)
instance Data.Functor.Classes.Eq1 Dep.Algorithm.Levenshtein.Edit
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Dep.Algorithm.Levenshtein.Edit a)
instance Data.Hashable.Class.Hashable1 Dep.Algorithm.Levenshtein.Edit
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Dep.Algorithm.Levenshtein.Edit a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Dep.Algorithm.Levenshtein.Edit a)
instance Control.DeepSeq.NFData1 Dep.Algorithm.Levenshtein.Edit
instance Data.Functor.Classes.Ord1 Dep.Algorithm.Levenshtein.Edit
